{"./":{"url":"./","title":"介绍","keywords":"","body":"算法分析与设计 章节 章节 名称 第一章 概述 第二章 排序 第三章 枚举 第四章 递归 第五章 贪心 第六章 深度优先搜索 第七章 广度优先搜索 Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-11-07 15:58:56 "},"slides/ch01.html":{"url":"slides/ch01.html","title":"第一章：概述","keywords":"","body":"第1章 概述 1.1 引言 算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。 一个算法的评价主要从时间复杂度和空间复杂度来考虑。 一个算法应该具有以下五个重要的特征： 有穷性 --- 执行有限条指令后一定要终止。 确定性(无二义) --- 算法的每一步操作都必须有确切定义，不得有任何歧义性。 可(能)行性 --- 算法的每一步操作都必须是可行的，即每步操作均能在有限时间内完成。 输入 --- 一个算法有n(n>=0)个初始数据的输入。 输出 --- 一个算法有一个或多个与输入有某种关系的有效信息的输出。 1.2 时间复杂度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 我们把问题的规模称之为 n ，例如排序问题中 n 为排序元素个数、图的问题中 n 是图的顶点数、矩阵中的 n 为矩阵的阶数等，当 n 不断变化时，花费时间也会不断变化，当我们想知道它变化时呈现什么规律时，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数f(n)，算法的时间度量记作 \r T(n) = O(f(n))\r 表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。 1.3 时间复杂度推导原则 如果运行时间是常数量级，用常数1表示； 只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数。 1.4 例题 问题：一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下。 算法2：对于数组B中的每一个数，都在A中通过二分的方式找一下。 算法3：先把数组B排序，然后用类似外排的方式打印所有不在A中出现的数。 时间复杂度： 算法1时间复杂度：O(M*N) 算法2时间复杂度：O(M*\\log_2^N) 算法3时间复杂度：O(M*\\log_2^M + M + N) 对数组A中M个数排序时间复杂度：O(M*\\log_2^M) 类似于外排方式打印不在数组A中的数时间复杂度：O(M+N) 例如：A[1, 3, 4, 5, 6]、B[8, 2, 5, 3]，B排序后变为[2, 3, 5, 8]。 i ↓ A: 1 3 4 5 6 B: 2 3 5 8 ↑ j for(i=0,j=0; i=A.length) 打印B[j]后面所有元素; Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-24 22:47:47 "},"slides/ch02.html":{"url":"slides/ch02.html","title":"第二章：排序","keywords":"","body":"第2章 排序 2.1 冒泡排序 重复地走访过要排序的元素，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。 冒泡排序是一种稳定排序算法。 时间复杂度 O(N^2) 冒泡排序示例 [2 4 3 1 6 5] 【初始状态】 ------------------------------------------------ [2 4 3 1 6 5] 【第一次冒泡开始】 \\__/ [2 4 3 1 6 5] \\__/ [2 3 4 1 6 5] \\__/ [2 3 1 4 6 5] \\__/ [2 3 1 4 6 5] \\__/ [2 3 1 4 5] [6] 【第一次冒泡结束】 ------------------------------------------------ [2 1 3 4] [5 6] 【第二次冒泡】 [1 2 3] [4 5 6] 【第三次冒泡】 [1 2] [3 4 5 6] 【第四次冒泡】 [1 2 3 4 5 6] 【第五次冒泡】 冒泡排序示例代码 void bubble_sort(int arr[], int len) { for (int i=0; i arr[j+1]) { swap(&arr[j], &arr[j]); } } } } 2.2 选择排序 从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。 时间复杂度 O(N^2) 选择排序示例 [2 4 3 1 6 5] 【初始状态】 ------------------------------------------------ i min j ↓ ↓ ↓ [2 4 3 1 6 5] 【第一次选择开始】 i min j ↓ ↓ ↓ [2 4 3 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min ↓ ↓ [2 3 4 1 6 5] \\__________/ [1] [3 4 2 6 5] 【第一次选择结束】 ------------------------------------------------ [1 2] [4 3 6 5] 【第二次选择】 [1 2 3] [4 6 5] 【第三次选择】 [1 2 3 4] [6 5] 【第四次选择】 [1 2 3 4 5 6] 【第五次选择】 选择排序示例代码 void select_sort(int A[], int n) { int min; for(int i=0; i A[j]) { min = j; } } // 将最小值与到本次循环的首元素交换 swap(&A[min], &A[i]); } } 2.3 插入排序 插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，直到全部插入完为止。插入排序算法适用于少量数据的排序。 插入排序是一种稳定排序算法。 时间复杂度 O(N^2) 插入排序示例 [2 4 3 1 6 5] 【初始状态】 [2] [4 3 1 6 5] │ │ ↓ [2 4] [3 1 6 5] 【第一次插入】 │ ┌───┘ ↓ [2 3 4] [1 6 5] 【第二次插入】 │ ┌───────────┘ ↓ [1 2 3 4] [6 5] 【第三次插入】 │ | ↓ [1 2 3 4 6] [5] 【第四次插入】 │ ┌───┘ ↓ [1 2 3 4 5 6] 【第五次插入】 插入排序示例代码 void insert_sort(int arr[], int n) { int j, temp; for(int i=1; i0 && arr[j-1]>temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } 2.4 希尔排序 希尔排序是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 希尔排序是不稳定的排序方法。 时间复杂度 O(N^{1.3}) 希尔排序示例 0 1 2 3 4 5 6 7 [5 7 8 3 1 2 4 6] 【初始状态】 ------------------------------------------------------------ [5 7 8 3 1 2 4 6] 【第一次分组 增量为4】 │ │ │ │ │ │ │ │ [5] │ │ │ [1] │ │ │ 第1组 [7] │ │ [2] │ │ 第2组 [8] │ [4] │ 第3组 [3] [6] 第4组 [1 2 4 3 5 7 8 6] 【第一次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] │ │ │ [5] │ │ │ 第1组 [2] │ │ [7] │ │ 第2组 [4] │ [8] │ 第3组 [3] [6] 第4组 ------------------------------------------------------------ [1 2 4 3 5 7 8 6] 【第二次分组 增量为2】 │ │ │ │ │ │ │ │ [1] │ [4] │ [5] | [8] │ 第1组 [2] [3] [7] [6] 第2组 [1 2 4 3 5 6 8 7] 【第二次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] │ [4] │ [5] | [8] │ 第1组 [2] [3] [6] [7] 第2组 ------------------------------------------------------------ [1 2 4 3 5 6 8 7] 【第三次分组 增量为1】 │ │ │ │ │ │ │ │ [1] [2] [4] [3] [5] [6] [8] [7] 第1组 [1 2 3 4 5 6 7 8] 【第三次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] [2] [3] [4] [5] [6] [7] [8] 第1组 希尔排序示例代码 void shell_sort(int arr[], int n) { int i,j; for(int d=n/2; d>0; d/=2) { for(i=d; i=0 && temp 2.5 归并排序 归并排序是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序是一种稳定排序算法。 时间复杂度 O(N*log^N) 归并排序示例 [8 4 5 7 1 3 6 2] 【初始状态】 / \\ [8 4 5 7] [1 3 6 2] 分 / \\ / \\ 解 [8 4] [5 7] [1 3] [6 2] / \\ / \\ / \\ / \\ [8] [4] [5] [7] [1] [3] [6] [2] ------ \\ / \\ / \\ / \\ / [4 8] [5 7] [1 3] [2 6] \\ / \\ / 合 [4 5 7 8] [1 2 3 6] 并 \\ / [1 2 3 4 5 6 7 8] 归并排序示例代码 void merge(int arr[],int temp[], int start, int mid, int end) { int i=start, j=mid+1, k=start; while(i!=mid+1 && j!=end+1) { if(arr[i] > arr[j]) temp[k++] = arr[j++]; else temp[k++] = arr[i++]; } while(i != mid+1) temp[k++] = arr[i++]; while(j != end+1) temp[k++] = arr[j++]; for(i=start; i= end) return; int mid = start + (end-start) / 2; // 避免溢出 merge_sort(arr, temp, start, mid); merge_sort(arr, temp, mid+1, end); merge(arr, temp, start, mid, end); } void merge_sort(int arr[], int len) { int * temp = (int *)malloc(sizeof(int) * len); merge_sort(arr, temp, 0, len-1); free(temp); } 2.5.1 递归的时间复杂度 master公式 \r T(N) = a * T(\\frac{N}{b}) + O(N^d)\r N ： 数据样本量 a ： 子过程调用次数 \\frac{N}{b} ： 子过程数据样本量 O(N^d) ： 除去递归之外的时间复杂度 \r 递归时间复杂度 = \r \\begin{cases} \r \tO(N^{log_b^a}) , &log_b^a>d \\\\\r \tO(N^{d}*{log^N}) , &log_b^a=d \\\\\r \tO(N^d) , &log_b^a 2.5.2 数组小和问题 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。 例：[2, 3, 4, 1, 5] 小和为17。 2左边比其小的数： 3左边比其小的数：2 4左边比其小的数：2、 3 1左边比其小的数： 5左边比其小的数：2、 3、 4、 1 思路：求数组中每个数左侧比其小的所有数的和，等同于求每个数右侧比其大的数的数量乘以这个数的和进行累加。 2.5.3 逆序对问题 在一个数组中，左边的数如果比右边的数大，则两个数构成一个逆序对，请输出逆序对数量。 例：[2, 3, 4, 1, 5] 逆序对数量为3，逆序对分别为(2,1)、(3,1)、(4,1)。 2.5.4 瑞士轮问题 在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。 本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折衷，既保证了比赛的稳定性，又能使赛程不至于过长。 2*N 名编号为 1~2N 的选手共进行 R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会对选手进行一次排名。排名的依据是选手的总分。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第2K – 1名和第2K名、…… 、第2N – 1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在 R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 例：根据下表3名选手实力值及初始分数，求取4轮对阵后排名第2的选手为：编号1选手 选手编号 [1] [2] [3] [4] 选手实力值 10 5 20 15 选手初始分(排名) 7(1) 6(3) 6(4) 7(2) 对阵情况 第1轮对阵后 7(2) 6(4) 7(3) 8(1) [1]-[4]     [2]-[3] 第2轮对阵后 7(3) 6(4) 8(2) 9(1) [4]-[1]     [3]-[2] 第3轮对阵后 8(3) 6(4) 9(1) 9(2) [4]-[3]     [1]-[2] 第4轮对阵后 9(2) 6(4) 10(1) 9(3) [3]-[4]     [1]-[2] 思路：首先根据初始分数排序，然后在每次对阵结束后分为胜者组和败者组，分组时保证先进行对阵的选手在前，后对阵的选手在后，这样既保证了胜者组和败者组两组先天有序，再进行归并排序的merge操作，准备下次对阵。时间复杂度：O(N*log^N +R*N) 2.6 快速排序 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序是不稳定的排序方法。 时间复杂度 O(N*log^N) 第一趟快速排序示例 i ←-- j ↓ ↓ [30 24 5 58 18 36 12 42 39] 【快速排序初始化】 ----------------------------------------------------------------- i j ↓ ↓ [30 24 5 58 18 36 12 42 39] 【交换元素】 \\___________________________/ ----------------------------------------------------------------- i --→ j ↓ ↓ [12 24 5 58 18 36 30 42 39] 【交换元素后】 ----------------------------------------------------------------- i j ↓ ↓ [12 24 5 58 18 36 30 42 39] 【交换元素】 \\_____________/ ----------------------------------------------------------------- i ←-- j ↓ ↓ [12 24 5 30 18 36 58 42 39] 【交换元素后】 ----------------------------------------------------------------- i j ↓ ↓ [12 24 5 30 18 36 58 42 39] 【交换元素】 \\___/ ----------------------------------------------------------------- ij ↓↓ [12 24 5 18 30 36 58 42 39] 【交换元素后】 ----------------------------------------------------------------- [12 24 5 18] 30 [36 58 42 39] 【第一趟快速排序结束】 快速排序示例代码 int partition(int arr[], int low, int high) { int i=low, j=high, pivot=arr[low]; while(ipivot) // 从右向左扫描 j--; if(i 2.6.1 分类问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。 思路：指针p从-1位置开始，规划p左侧为小于num的数的区域，然后准备一个指针q指向下标0位置，如果q指向元素小于等于num，则q指向元素与p+1指向元素交换，p、q往后移动；如果q指向元素大于num，则q往后移动，直到q移出数组 2.6.2 荷兰国旗问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。 2.7 堆排序 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆排序是不稳定的排序方法。 时间复杂度 O(N*log^N) 堆排序示例代码 void max_heapify(int arr[], int start, int end) { // 父节点下标和子节点下标 int dad = start, son = dad * 2 + 1; while (son arr[son]) // 父节点大于子节点跳出函数 return; else { // 否则交换父子节点，并继续子节点和孙节点比较 swap(&arr[dad], &arr[son]); dad = son; son = dad * 2 + 1; } } } void heap_sort(int arr[], int len) { // 最后一个非叶子节点为(len-2)/2 for (int i=len/2-1; i>=0; i--) max_heapify(arr, i, len - 1); // 先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕 for (int i=len-1; i>0; i--) { swap(&arr[0], &arr[i]); max_heapify(arr, 0, i - 1); } } 2.7.1 建堆方法：HeapInsert 假定事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。大致步骤如下： 首先增加堆的长度，在最末尾的地方加入最新插入的元素。 比较当前元素和它的父结点值，如果比父结点值大，则交换两个元素，否则返回。 重复步骤2。 这种插入建堆的时间复杂度是 O(N*log^N) HeapInsert 建堆示例 2.7.2 建堆方法：Heapify 从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换，并持续往下递归调整。Heapify是一种类似下沉的操作，HeapInsert是一种类似上浮的操作。 这种建堆的时间复杂度是 O(N) 怎么找到第一个非叶子节点? 如果根节点在数组中的索引为0，那么第一个非叶子节点的计算公式为: last\\_non\\_leav = (arr.length - 2)/2 可以设最后一个非叶子节点位置为x，那么最后一个叶子节点一定是(2x+1) 或者(2x+2)中的一个，然后可以建立方程求解。 Heapify 建堆示例 2.7.3 堆排序示例 将堆顶节点与末尾节点进行交换，使末尾节点最大。然后继续调整堆，再将堆顶节点与末尾节点交换，得到第二大节点。如此反复进行交换、重建、交换。 2.8 桶排序 桶排序或所谓的箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 桶排序是一种稳定排序算法。 平均时间复杂度 O(N+C)，其中 C=N*(logN-logM)，N 为待排数据，M为桶数量。当N=M时，最好效率达到 O(N)。 桶排序示例 桶排序示例代码 #include #include #include using namespace std; // 桶的数量 const int BUCKET_NUM = 10; void bucket_sort(int arr[], int len) { vector buckets[BUCKET_NUM]; // 求取最大值及最小值，确定桶区间范围 int max=arr[0], min=arr[0]; for (int i=1; i arr[i]) min = arr[i]; } // 将数据放入不同的桶中 for (int i=0; i newArr; for (int i=0; i 2.8.1 相邻元素最大差值 给定一个数组，求如果排序之后，相邻两数的最大差值。 思路：根据数组元素数值范围，准备N+1个桶，然后根据桶排序思想将所有元素放入桶中，则必然会存在有一个空桶，便可以排除排序后相邻元素出现在一个桶中的可能性，然后遍历每个桶，求相邻桶（跳过空桶）极值元素最大差值即可，时间复杂度O(N)。 2.9 计数排序 计数排序是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。 计数排序是一种稳定排序算法。 算法过程： 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间； 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内； 对额外空间内数据进行计算，得出每一个元素的正确位置； 将待排序集合每一个元素移动到计算得出的正确位置上。 时间复杂度 O(N+K) （K为数值范围） 计数排序示例代码 void count_sort(int arr[], int len) { if(lenarr[i]) min = arr[i]; } // 临时数组 int * newArr = (int *)malloc(sizeof(int)*len); int n = max-min+1; // 辅助数组 int * p = (int *)malloc(sizeof(int)*n); memset(p, 0, sizeof(int)*n); // 统计各元素出现次数 for(int i=0; i=0; i--) { newArr[p[arr[i]-min]-1]=arr[i]; p[arr[i]-min]--; } // 将排序好的元素拷贝回arr memcpy(arr, newArr, sizeof(int)*len); free(newArr); free(p); } 2.10 基数排序 基数排序属于“分配式排序”，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。 基数排序是一种稳定排序算法。 时间复杂度 O(D*N) （D为基数位数） 基数排序示例代码 // 辅助函数，求数据的最大位数 int max_bit(int data[], int n) { int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i = p) { p *= 10; ++d; } } return d; } void radix_sort(int arr[], int len) { int bit = max_bit(arr, len); int * tmpArr = (int *)malloc(sizeof(int)*len); int * countArr = (int *)malloc(sizeof(int)*10); int radix = 1; for(int i=1; i=0; --j) { int k = (arr[j]/radix)%10; tmpArr[countArr[k]-1] = arr[j]; countArr[k]--; } // 将临时数组的内容复制到原数组中 for(int j=0; j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-24 22:47:47 "},"slides/ch03.html":{"url":"slides/ch03.html","title":"第三章：枚举","keywords":"","body":"第3章 枚举 把问题所有可能的解一一进行检验，排除后得到正确可行解的过程称为枚举，这种方法是牺牲时间和空间来换取较高的准确性，所以当可能的解范围较大时，一般不建议使用这种方法。 枚举的时间复杂度一般为所有可能解的范围，但在绝大多数情况下，可以进行优化处理，缩小可能解的范围，或者根据问题的相关性质有选择性的跳跃搜索正解。 枚举简单粗暴，当可能的解范围确定时，暴力枚举所有可能的解，使用枚举算法时，要保证可能的解范围确定，并且一定能在这个范围内找到正解，其本质上就是搜索。 3.1 水仙花数 [题面] 水仙花数是指一个 n 位数（n \\geq 3），它每个位上的数字的 n 次幂之和等于它本身（如 1^3+5^3+3^3=153 ），求出所有三位数的水仙花数。 [输入] 无输入。 [输出] 从小到大顺序输出所有水仙花数，每行输出一个水仙花数。 [思路1] 直接遍历100~999，判断每个数是否满足是水仙花数的条件。判断的时候把每个数拆分出个位、十位、百位，然后判断是否满足。 [思路2] 利用三重循环，分别模拟个位、十位、百位，然后输出满足条件的数。 3.2 百钱买百鸡 [题面] 元前五世纪，我国古代数学家张丘建在《算经》一书中提出了“百鸡问题”：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 本程序要求解的问题是：给定一个正整数n，用n文钱买n只鸡，问公鸡、母鸡、小鸡各买多少只？ [输入] 输入一个正整数 n(n。 [输出] 如果有解，每种组合占一行，包含公鸡、母鸡、小鸡的个数，用正整数表示，每个数据占4列。公鸡母鸡小鸡个数均大于等于0，按公鸡数目从小到大输出，公鸡数目相同按母鸡数目从小到大输出，以此类推。如果无解，输出“No Answer”。 [样例输入] 100 [样例输出] 0 25 75 4 18 78 8 11 81 12 4 84 [思路1] 根据题意，假设 x 只公鸡， y 只母鸡， z 只小鸡，可以得到方程组 \r \\begin{cases} \r \t5x+3y+z/3 = n \\\\\r \tx+y+z = n\r \\end{cases}\r 其中， 0 \\leq x,y,z \\leq n \\ \\ \\& \\& \\ \\ z \\% 3 == 0 ，然后可以对其进行一一枚举。 [思路2] 通过已知条件对方法1进行优化，减少枚举次数。3种鸡的总数是固定的，只需要枚举公鸡和母鸡，即可确定小鸡的数量 z == n-x-y ，这样就缩小了枚举范围，去掉一个未知数，得到 \r \\begin{cases}\r \t7x+4y=n \\\\\r \tx+y+z=n\r \\end{cases}\r 其中， 0 \\leq x,y,z \\leq n \\ \\ \\& \\ \\ z \\% 3 == 0 中的 x 值可以缩小范围为 0 \\leq x \\leq \\frac{n}{4} 。 [参考代码] #include int main(void) { int n, x, y, z; scanf(\"%d\", &n); for(x=0; x=0) { y /= 4; z = 100-x-y; if(z%3==0 && 5*x+3*y+z/3==n) printf(\"%d %d %d\\n\", x, y, z); } } return 0; } 3.3 完美立方 [题面] 形如 a^3 = b^3 + c^3 + d^3 的等式被称为完美立方等式。例如 12^3 = 6^3 + 8^3 + 10^3 。编写一个程序，对任给的正整数 N(N \\leq 100) ，寻找所有的四元组 (a, b, c, d) ，使得 a^3= b^3 + c^3 + d^3 ，其中a,b,c,d 大于 1, 小于等于N，且 b \\leq c \\leq d。 [输入] 一个正整数 N (N \\leq 100)。 [题面] 每行输出一个完美立方。 输出格式为： Cube = a, Triple = (b,c,d) 其中a，b，c，d所在位置分别用实际求出四元组值代入。 请按照a的值，从小到大依次输出。当两个完美立方等式中a的值相同，则b值小的优先输出，仍相同则c值小的优先输出，再相同则d值小的先输出。 [样例输入] 24 [样例输出] Cube = 6, Triple = (3,4,5) Cube = 12, Triple = (6,8,10) Cube = 18, Triple = (2,12,16) Cube = 18, Triple = (9,12,15) Cube = 19, Triple = (3,10,18) Cube = 20, Triple = (7,14,17) Cube = 24, Triple = (12,16,20) [思路] 使用四重循环枚举a、b、c、d，a在最外层，d在最里层，每一层都是从小到大枚举。 a的枚举范围：[ 2, N ] b的枚举范围：[ 2, a-1 ] c的枚举范围：[ b, a-1 ] d的枚举范围：[ c, a-1 ]​ [参考代码] #include int main(void) { int n; scanf(\"%d\", &n); for(int a=2; a 3.4 生理周期 [题面] 人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为23天、28天和33天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为10，下次出现三个高峰同天的时间是12，则输出2（注意这里不是3）。 [输入] 多组数据。一行包含四个整数：p, e, i和d，相邻两个整数之间用单个空格隔开。 p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于p, e, 或 i。 所有给定时间是非负的并且小于等于365, 所求的时间小于等于21252。 [输出] 对每组数据输出一行，每行一个整数，即从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。 [样例输入] 0 0 0 0 0 0 0 100 5 20 34 325 4 5 6 7 283 102 23 320 203 301 203 40 [样例输出] 21252 21152 19575 16994 8910 10789 [思路] 从d+1天开始，一直试到第21252天，对其中每个日期k，看是否满足如下条件。 (k-p) \\% 23 == 0 \\ \\ \\&\\&\\ \\ (k-e) \\% 28 == 0 \\ \\ \\&\\& \\ \\ (k-i) \\% 33 == 0 根据题意，对算法进行优化即可。 [参考代码] #include int main(void) { int p, e, i, d; while(~scanf(\"%d %d %d %d\", &p, &e, &i, &d)) { int k; for(k=d+1; (k-p)%23; ++k); for(; (k-e)%28; k+=23); for(; (k-i)%33; k+=23*28); printf(\"%d\\n\", k-d); } return 0; } 3.5 假币问题 赛利有12枚银币。其中有11枚真币和1枚假币。假币看起来和真币没有区别，但是重量不同。但赛利不知道假币比真币轻还是重。于是他向朋友借了一架天平。朋友希望赛利称三次就能找出假币并且确定假币是轻是重。例如：如果赛利用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果赛利用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。经过精心安排每次的称量，赛利保证在称三次后确定假币。 [输入] 第一行有一个数字n，表示有n组测试用例。 对于每组测试用例： 输入有三行，每行表示一次称量的结果。赛利事先将银币标号为A-L。每次称量的结果用三个以空格隔开的字符串表示：天平左边放置的硬币 天平右边放置的硬币 平衡状态。其中平衡状态用\"up\"，\"down\"， 或 \"even\"表示，分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。 [输出] 输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)。 [样例输入] 1 ABCD EFGH even ABCI EFJK up ABIJ EFGH even [样例输出] K is the counterfeit coin and it is light. [思路] 对每一枚硬币先假设它是轻的，看这样是否符合称重的结果，如果符合，问题即解决。如果不符合，就假设它是重的，看是否符合称重的结果。把所有的硬币都试一遍，一定能找到特殊的硬币。 [参考代码] #include #include char left[3][13]; // 天平左边的硬币 char right[3][13]; // 天平右边的硬币 char result[3][6]; // 结果 // light为1表示假设假币为轻，0表示为重 int isFake(char c, int light) { for(int i=0; i 3.6 猜数字 [题面] 猜数字游戏是gameboy最喜欢的游戏之一。游戏的规则是这样的：计算机随机产生一个四位数，然后玩家猜这个四位数是什么。每猜一个数，计算机都会告诉玩家猜对几个数字，其中有几个数字在正确的位置上。 比如计算机随机产生的数字为1122。如果玩家猜1234,因为1,2这两个数字同时存在于这两个数中，而且1在这两个数中的位置是相同的，所以计算机会告诉玩家猜对了2个数字，其中一个在正确的位置。如果玩家猜1111,那么计算机会告诉他猜对2个数字，有2个在正确的位置。 现在给你一段gameboy与计算机的对话过程，你的任务是根据这段对话确定这个四位数是什么。 [输入] 输入数据有多组。每组的第一行为一个正整数N(1 \\leq N \\leq 100)，表示在这段对话中共有N次问答。在接下来的N行中，每行三个整数A,B,C。gameboy猜这个四位数为A，然后计算机回答猜对了B个数字，其中C个在正确的位置上。当N=0时，输入数据结束。 [输出] 每组输入数据对应一行输出。如果根据这段对话能确定这个四位数，则输出这个四位数，若不能，则输出“Not sure”。 [样例输入] 6 4815 2 1 5716 1 0 7842 1 0 4901 0 0 8585 3 3 8555 3 2 2 4815 0 0 2999 3 3 0 [样例输出] 3585 Not sure [思路] 因为随机产生的数一定是四位数，所以求解范围不大，可以使用枚举的方法。对于每一个四位数，判断其是否与输入中的对话冲突，但是在找到一个符合条件的数时，仍要继续枚举，指导出现第二个符合条件的数或者枚举完所有的四位数时，枚举结束。当有两个符合条件的数或者枚举结束都没找到一个符合条件的数时，输出“Not sure”，当且仅有一个符合条件数时，输出这个数。 [参考代码] #include #include const int N = 110; struct Arr{ int a,b,c; } arr[N]; int hashA[10], hashB[10]; int judge(int y, int n) { memset(hashA, 0, sizeof(hashA)); int A1, B1, C1, D1, A2, B2, C2, D2; A1 = y%10; hashA[A1]++; B1 = y/10%10; hashA[B1]++; C1 = y/100%10; hashA[C1]++; D1 = y/1000; hashA[D1]++; for(int i=0; i 3.7 熄灯问题 [题面] 有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。 在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。 请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。 [输入] 5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。 [输出] 5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。 [样例输入] 0 1 1 0 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 1 0 1 0 1 1 1 0 0 [样例输出] 1 0 1 0 0 1 1 1 0 1 0 1 0 0 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 [思路] 按下按钮顺序不影响最终结果； 按下一个按钮两次等价于没有按这个按钮，故每个按钮最多只需按一次。 一共30个开关，那么状态数是2^{30}，需要减少枚举的状态数目。 基本思路：如果存在某个局部，一旦这个局部状态被确定，那么剩余其它部分的状态只能是确定的一种，或者不多的n种，那么就只需枚举这个局部的状态即可。 经过观察，发现第1行就是这样一个“局部”。 因为第1行的各开关状态确定的状态下，这些开关作用过后，将导致第1行某些灯是亮的，某些灯是灭的。 要熄灭第1行某个亮着的灯（假设位于第i列），那么唯一的方法就是第2行第i列的按钮。（因为第1行的开关已经用过了，而第3行及其后面的开关不会影响到第1行） 为了使第1行的灯全部熄灭，第2行的合理开关状态就是唯一的。 枚举第1行状态数是2^6，同理枚举第1列状态数是2^5。 因为按钮状态只有开关两种，所以在是现实时可以通过位运算来实现。 [参考代码] #include #include int get_bit(char c, int i) { return (c >> i) & 1; } void set_bit(char &c, int i, int v) { if(v) c |= (1 0) flip_bit(lights[i], j-1); // 更改开关位置灯状态 flip_bit(lights[i], j); // 更改右等状态 if(j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-24 22:47:47 "},"slides/ch04.html":{"url":"slides/ch04.html","title":"第四章：递归","keywords":"","body":"第4章 递归 一个函数直接或者间接调用自己本身，这种函数称为递归函数，而递归算法是把问题转化为规模缩小了的同类问题的子问题，然后调用递归函数表示问题的解，其思想是将一个大型而且复杂的问题层层简化，转化为一个与原问题相似的规模较小且简单的子问题，通过多次调用子问题得到最终复杂问题的解。 在递归调用的过程中，系统为每一层的返回点、局部变量等开辟了栈来存储，为了避免栈溢出的问题，递归需要有边界条件，必须有一个明确的递归出口。 4.1 母牛的故事 [题面] 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第 n 年的时候，共有多少头母牛？ [输入] 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数 n(0，n 的含义如题目中描述。 n=0 表示输入数据的结束，不做处理。 [输出] 对于每个测试实例，输出在第 n 年的时候母牛的数量。 每个输出占一行。 [样例输入] 2 4 5 0 [样例输出] 2 4 6 [思路] 假设第 n 年母牛数为 cow[n]，根据题意可以知道 cow[1] =1， cow[2] = 2， cow[3] = 3；当 n>3 时，就要推公式再进行递归求解。第 n 年的母牛数可以分为两部分；第一部分为第 n-1 年的母牛总数；第二部分为第 n 年年初刚生育的小牛数，而第 n 年年初刚生育的小牛数等于第 n-3 年的母牛总数。所以，当 n>3 时，cow[n] = cow[n-1] + cow[n-3]。 为了减少不必要的重复递归，可以使用数组 cow[i] 进行记忆化递归。 [参考代码] #include int cow[60] = {0}; int cowNumber(int n) { if(cow[n]) return cow[n]; if(n 4.2 汉诺塔问题 [题面] 法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。 不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有 n 片，移动次数是f(n)。 显然 f(1)=1,f(2)=3,f(3)=7，且 f(k+1)=2*f(k)+1。此后不难证明 f(n)=2^n-1。n=64时， 假如每秒钟一次，共需多长时间呢？一个平年365天有31536000秒，闰年366天有31622400秒，平均每年31556952秒，计算一下： 18,446,744,073,709,551,615秒 这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 [输入] 输入为一个整数后面跟三个单字符字符串。 整数为盘子的数目，后三个字符表示三个杆子的编号。 [输出] 输出每一步移动盘子的记录。一次移动一行。 每次移动的记录为例如3:a->b 的形式，即把编号为3的盘子从a杆移至b杆。 我们约定圆盘从小到大编号为 1, 2, ...n。即最上面那个最小的圆盘编号为1，最下面最大的圆盘编号为 n。 [样例输入] 3 a b c [样例输出] 1:a->c 2:a->b 1:c->b 3:a->c 1:b->a 2:b->c 1:a->c [思路] 解法的基本思想是递归。假设有A、B、C三个塔，A塔有N块盘，目标是把这些盘全部移到C塔。那么先把A塔顶部的N-1块盘移动到B塔，再把A塔剩下的大盘移到C，最后把B塔的N-1块盘移到C。 每次移动多于一块盘时，则再次使用上述算法来移动。 [参考代码] #include // 将src座上的n个盘子以mid座为中转移动到dest座， // src座上最上方盘子编号是src_n void hanoi(int n, char src, char mid, char dest, int src_n) { if(n == 1) { // 只需移动一个盘子，直接将盘子从src移动到dest即可 printf(\"%d:%c->%c\\n\", src_n, src, dest); return; } // 先将n-1个盘子从src移动到mid hanoi(n-1, src, dest, mid, src_n); // 再将第n个盘子从src移动到dest printf(\"%d:%c->%c\\n\", src_n+n-1, src, dest); // 最后将n-1个盘子从mid移动到dest hanoi(n-1, mid, src, dest, src_n); return ; } int main(void) { char a, b, c; int n; scanf(\"%d %c %c %c\", &n, &a, &b, &c); hanoi(n, a, b, c, 1); return 0; } 4.3 逆波兰表达式 [题面] 逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的逆波兰表示法为* + 2 3 4。本题求解逆波兰表达式的值，其中运算符包括+ - * /四个。 [输入] 输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 [输出] 输出为一行，表达式的值。 可直接用printf(\"%f\\n\", v)输出表达式的值v。 [样例输入] * + 11.0 12.0 + 24.0 35.0 [样例输出] 1357.000000 [提示] 样例输入含义：(11.0+12.0)*(24.0+35.0) 可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在stdlib.h中。 此题可使用函数递归调用的方法求解。 [思路] 本题中“逆波兰表达式”的定义： 一个数是一个逆波兰表达式，值为该数 \"运算符 逆波兰表达式 逆波兰表达式\" 是逆波兰表达式，值为两个逆波兰表达式的值运算的结果 一般教科书将本题中的“逆波兰表达式”称为“波兰表达式”，而将运算符后置的表达式成为“逆波兰表达式” [参考代码] #include #include double exp() { char s[100]; scanf(\"%s\", s); switch(s[0]) { case '+': return exp() + exp(); case '-': return exp() - exp(); case '*': return exp() * exp(); case '/': return exp() / exp(); default: return atof(s); } } int main(void) { printf(\"%f\\n\", exp()); return 0; } 4.4 N皇后问题 [题面] 在 N*N 的方格棋盘放置了 N 个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。 你的任务是，对于给定的 N，求出有多少种合法的放置方法。 [输出] 共有若干行，每行一个正整数 N≤10，表示棋盘和皇后的数量；如果 N=0，表示结束。 [输出] 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 [样例输入] 1 8 5 0 [样例输出] 1 92 10 [思路] 通过递归逐层枚举皇后存放位置即可，具体过程看代码注释。 [参考代码] #include #include // 用来存放算好的皇后位置，最左上角是(0,0) int queenPos[100]; // counts[i]=j 表示i个皇后时摆放情况有j个 int counts[10]; // 在0~k-1 行皇后已经摆好的情况下，摆第k行及其后的皇后 void putQueen(int k, int n) { // N 个皇后已经摆好 if(k == n) { counts[n]++; return ; } // 逐列尝试寻找第k个皇后的位置 for(int i=0; i 4.5 EOF牛肉串 [题面] 今年的ACM暑期集训队一共有18人，分为6支队伍。其中有一个叫做EOF的队伍，由04级的阿牛、XC以及05级的COY组成。在共同的集训生活中，大家建立了深厚的友谊，阿牛准备做点什么来纪念这段激情燃烧的岁月，想了一想，阿牛从家里拿来了一块上等的牛肉干，准备在上面刻下一个长度为n的只由\"E\" \"O\" \"F\"三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）,阿牛同时禁止在串中出现O相邻的情况，他认为，\"OO\"看起来就像发怒的眼睛，效果不好。 你能帮阿牛算一下一共有多少种满足要求的不同的字符串吗？ [输入] 输入数据包含多个测试实例,每个测试实例占一行，由一个整数 n 组成，(0。 [输出] 对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。 [样例输入] 1 2 [样例输出] 3 8 [思路] 因为两个 O 不能连在一起，所以考虑两种单独的情况。设长度为 n 时的 x[n]=a[n]+b[n]，其中，a[n] 代表长度为 n 时末尾为 O 的情况总和， b[n] 代表长度为 n 时末尾不为 O 的情况总和。 那么分情况讨论： 当长度为 n，末尾为 O 时，再加一个单位的长度有两种加法，即 E，F。 当长度为 n，末尾不为 O 时，再加一个单位的长度有三种加法，即 E，O，F。 所以 x[n+1] = a[n+1] + b[n+1] = 2*a[n] + 3*b[n] = 2*x[n] + b[n] 。 而 b[n] 又由 x[n-1] 推来，x[n-1] = a[n-1] + b[n-1]，在长度为 n-1 且末尾为 O 时，要将它变成长度为 n 且末尾不为 O 有两种方法（E，F），即 2*a[n-1]​。 同理，在长度为 n-1 且末尾不为 O 时，要将它变成长度为 n 且末尾不为 O 有两种方法（E，F），即 2*b[n-1]。 所以 x[n+1] = 2*x[n] + b[n] = 2*x[n] + 2*x[n-1]。 [参考代码] #include int main(void) { long long arr[50] = {0}; arr[1] = 3; arr[2] = 8; for(int i=3; i 4.6 RPG难题 [题面] 著名的RPG难题: 有排成一行的 ｎ 个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色。求全部的满足要求的涂法。 [输入] 输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0 [输出] 对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。 [样例输入] 1 2 [样例输出] 3 6 [思路] 当长度为 n 时，满足要求的涂法为 x[n]，设3中颜色为A、B、C，由 x[n] 推出 x[n+1]。 若长度为 n 时，序列为 ABC···BAC，那么在后面加一个，只有一种加法，因为既要与开头不一样，又要与末尾不一样，所以只能加 B，因此从 n 变为 n+1 只有一种方法。 然而，还有种情况忽略了，就是当长度为 n-1 时，序列为 ABC···CB 时，若在其后加一个 A 变成 ABC···CBA 是不符合题意的，但可以在后面加两个让其变得有意义，如 ABC···CBAC 或者 ABC···CBAB，可得出从 n-1 变为 n+1 有两种方法。 所以，可以退出公式 x[n] = x[n-1] + 2*x[n-2]。 [参考代码] #include int main(void) { long long arr[60] = {0}; arr[1] = 3; arr[2] = arr[3] = 6; for(int i=4; i 4.7 放苹果 [题面] 把 M 个同样的苹果放在 N 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。 [输入] 第一行是测试数据的数目 t(0 \\leq t \\leq 20)。以下每行均包含二个整数 M 和 N ，以空格分开。1 \\leq M，N \\leq 10。 [输出] 对输入的每组数据 M 和 N ，用一行输出相应的K。 [样例输入] 1 7 3 [样例输出] 8 [思路] 设 M 个苹果放在 N 个盘子里放法总数是 f(M,N)，则： N > M 时，f(M,N) = f(M,M) N 时，总放法 = 有盘子为空的放法 + 没盘子为空的放法 f(M,N) = f(M,N-1) + f(M-N,N) 边界条件：当苹果数为0时，1种放法；当盘子数为0时，0种放法。 [参考代码] #include int f(int m, int n) { if(n > m) return f(m, m); if(m == 0) return 1; if(n 4.8 算24 [题面] 给出4个小于10个正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。 这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。 比如，对于5，5，5，1，我们知道 5 * (5 – 1 / 5) = 24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到 24。 [输入] 输入数据包括多行，每行给出一组测试数据，包括4个小于10个正整数。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。 [输出] 对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。 [样例输入] 5 5 5 1 1 1 4 2 0 0 0 0 [样例输出] YES NO [思路] n 个数算 24 ，必有两个数要先算。这两个数算的结果，和剩余 n-2 个数，就构成了 n-1 个数求 24 的问题。 枚举先算的两个数，以及这两个数的运算方式。 边界条件：一个数算 24 注意：浮点数不能直接判等。 [参考代码] #include #include #include #define EPS 1e-6 int isZero(double x) { return fabs(x) 4.9 *四则运算表达式求值 [题面] 求一个可以带括号的小学算术四则运算表达式的值。 [输入] 一行，一个四则运算表达式。'*'表示乘法，'/'表示除法。 [输出] 一行，该表达式的值，保留小数点后面两位。 [样例输入1] 3.4 [样例输出1] 3.40 [样例输入2] 7+8.3 [样例输出2] 15.30 [样例输入3] 3+4.5*(7+2)*(3)*((3+4)*(2+3.5)/(4+5))-34*(7-(2+3)) [样例输出3] 454.75 [思路] 表达式是一个递归定义，因此可对表达式进行递归分析处理。 [参考代码] #include #include #include #include using namespace std; double expression_value(); double term_value(); double factor_value(); // 获取一个表达式的值 double expression_value() { // 求第一项的值 double result = term_value(); while(1) { // 从缓存区获取一个字符，并不从缓存区取走 char op = cin.peek(); if('+'==op || '-'==op) { // 从缓存区读出运算符 cin.get(); // 从缓存区读取另一项的值 double value = term_value(); if('+' == op) result += value; else result -= value; } else break; } return result; } // 获取一个项的值 double term_value() { // 求第一个因子的值 double result = factor_value(); while(1) { char op = cin.peek(); if('*'==op || '/'==op) { // 从缓存区读出运算符 cin.get(); // 读取运算符后的另一个因子的值 double value = factor_value(); if('*' == op) result *= value; else result /= value; } else break; } return result; } // 获取一个因子的值 double factor_value() { double result = 0; char c = cin.peek(); if('(' == c) { cin.get(); // 从缓存区读出 '(' // 读取括号中表达式的值 result = expression_value(); cin.get(); // 从缓存区读出 ')' } else { // 读取小数点前面数值 while(isdigit(c)) { result = result*10 + (c-'0'); cin.get(); c = cin.peek(); } // 如果存在小数点读取小数点后面数值 if('.' == c) { cin.get(); c = cin.peek(); double f = 0.1; while(isdigit(c)) { result = result + (c-'0')*f; f *= 0.1; cin.get(); c = cin.peek(); } } } return result; } int main(void) { printf(\"%.2lf\\n\", expression_value()); return 0; } Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-24 22:47:47 "},"slides/ch05.html":{"url":"slides/ch05.html","title":"第五章：贪心","keywords":"","body":"第5章 贪心 贪心算法是指在对问题求解时，总是选取当前最优策略的算法，其不是从整体上考虑，而是从某种意义上得到局部的最优解，使用贪心算法时，一定要保证无后效性，即当前选择的状态不会对以后的状态产生影响。 求解时，把问题分为若干个子问题进行求解，得到子问题的局部最优解，因为其满足无后效性，局部最优解能导致全局最优解。 5.1 圣诞老人的礼物 [题面] 圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。 [输入] 第一行由两个部分组成，分别为糖果箱数正整数 n(1 \\leq n \\leq 100)，驯鹿能承受的最大重量正整数 w(0 ，两个数用空格隔开。其余 n 行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数 v 和重量正整数 w ，中间用空格隔开。 [输出] 输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。 [样例输入] 4 15 100 4 412 8 266 7 591 2 [样例输出] 1193.0 [思路] 按礼物的 价值/重量 比从大到小依次选取礼物，对选取的礼物尽可能多地装，直到达到总重量 w 。 [参考代码] #include #include using namespace std; const double eps = 1e-6; struct Candy { int v; int w; bool operator eps; } } candies[110]; int main(void) { int n, w; scanf(\"%d %d\", &n, &w); for(int i=0; i 5.2 电影节 [题面] 大学生电影节在北大举办! 这天，在北大各地放了多部电影，给定每部电影的放映时间区间，区间重叠的电影不可能同时看（端点可以重合），问李雷最多可以看多少部电影。 [输入] 多组数据。每组数据开头是 n(n \\leq 100)，表示共 n 场电影。 接下来 n 行，每行两个整数(0到1000之间)，表示一场电影的放映区间。 n=0 则数据结束。 [输出] 对每组数据输出最多能看几部电影 [样例输入] 8 3 4 0 7 3 8 15 19 15 20 10 15 8 18 6 12 0 [样例输出] 3 [思路] 将所有电影按结束时间从小到大排序，第一步选结束时间最早的那部电影。然后，每步都选和上一部选中的电影不冲突且结束时间最早的电影。 [参考代码] #include #include #include using namespace std; struct film{ int s; int e; bool operator= endtime){ endtime = films[i].e; sum++; } } printf(\"%d\\n\", sum); } return 0; } 5.3 做作业 [题面] Ignatius有很多作业要做，每门作业都有一个最迟期限，如果没有在最迟期限内完成，就会扣除相应的分数。假设做每门作业都要一天时间，你能帮他规划出扣分最少的做作业顺序吗？ [输入] 输入包含多组测试数据。输入的第一行为一个数 T，表示测试组数，接下来包括 T 组测试数据，每组测试数据的第一行为一个整数 N(1 \\leq N \\leq 1000)，表示作业门数，接下来有两行，第一行有 N 个数字，分别表示每门作业的最迟期限，第二行有 N 个数字，分别表示未完成作业扣除的相应分数。 [输出] 对于每组测试数据，输出扣除的最少分数，每行对应一个数据答案。 [样例输入] 3 3 3 3 3 10 5 1 3 1 3 1 6 2 3 7 1 4 6 4 2 4 3 3 2 1 7 6 5 4 [样例输出] 0 3 5 [思路] 题目中求解扣除的最少分数，那么从分数下手，优先完成分数高的作业，所以将作业按照分数进行排序，其次考虑怎样安排顺序。 作业: A B C D E F G 期限: 1 4 6 4 2 4 3 扣分: 3 2 1 7 6 5 4 用样例3来分析，假设第一天做了“作业A”，第二天做了“作业E”，第三天做了“作业G”，那么第四天会选择扣分更高的“作业D”，若这样安排，第四天会产生扣分7（“作业B” + “作业F”），很明显不是最优解。 其实可以用第三天做“作业F”，第一天做“作业G”，这样就能达到最优解，所以我们不能正向考虑，应该把时间用来做尽可能扣分高的作业，直接按照时间从大到小进行枚举，判断在最迟期限前是否能完成它，需要用到一个标记数组来辅助判断该天是否已被占用。 [参考代码] #include #include #include #include const int N = 1010; struct Work { int time; int score; friend bool operator b.score; } } workArr[N]; int doneArr[N]; int main(void) { int t, n; scanf(\"%d\", &t); while(t--) { scanf(\"%d\", &n); for(int i=0; i 5.4 保护花园 [题面] 农夫去砍柴，留下了 N(2 \\leq N \\leq 100,000) 头牛吃草，等农夫砍柴回来发现所有的牛都在花园中破坏花朵。农夫决定依次将每头牛牵回牛棚，但在这个过程中，其它仍留在花园中的牛会继续破坏花朵，牵一头牛回牛棚的单程时间为 Ti(1 \\leq Ti \\leq 2,000,000)，牛在花园中每分钟破坏花朵数为 Di(1 \\leq Di \\leq 100) 。请编写一段程序，决定牵牛回牛棚的顺序以保证破坏的总花朵数最少。 [输入] 第一行：一个整数 N 。 第二行到第N+1行：每一行包括两个整数，分别表示为 Ti 和 Di 。 [输出] 输出一个数字表示被破坏的最少花朵数。 [样例输入] 6 3 1 2 5 2 3 3 2 4 1 1 6 [样例输出] 86 [思路] 因为牵一头牛的单程时间是 Ti ，当把一头牛牵到牛棚再回来牵第二头牛的时间为 2*Ti ，假设两头牛分别为 CowX、CowY，分别对应 CowXt、CowXd、CowYt、CowYd 。 如果先牵 CowX，那么被破坏的花朵数为 2 * CowXt * CowYd 。 如果先牵 CowY，那么被破坏的花朵数为 2 * CowYt * CowXd 。 对于上面两个式子同时除以 2 * CowXt * CowYt 可以分别得到 \\frac{CowYd}{CowYt}，\\frac{CowXd}{CowXt} 。 那么当 \\frac{CowYd}{CowYt} 时，表示先牵 CowX 更优，反之则牵 CowY 更优，综上把每头牛的 Di 和 Ti 相除按照从大到小的顺序排序，再枚举可求值。 [参考代码] #include #include typedef long long ll; const int N = 100010; struct Cow { int t; int d; friend bool operator 1.0*b.d/b.t; } } cowArr[N]; int main(void) { int n; scanf(\"%d\", &n); ll sumD = 0; for(int i=0; i 5.5 畜栏保留问题 [题面] 农场有 N 头牛，每头牛会在一个特定的时间区间 [A, B]（包括A和B）在畜栏里挤奶，且一个畜栏里同时只能有一头牛在挤奶。现在农场主希望知道最少几个畜栏能满足上述要求，并要求给出每头牛被安排的方案。对于多种可行方案，主要输出一种即可。（Special judged） 去同一个畜栏的两头牛，它们挤奶时间区间哪怕只在端点重合也是不可以的。 [输入] 输入的第一行包含一个整数 N(1 \\leq N \\leq 50, 000)，表示有 N 牛头；接下来 N 行每行包含两个数，分别表示这头牛的挤奶时间 [Ai, Bi] (1 \\leq A \\leq B \\leq 1, 000, 000)。 [输出] 输出的第一行包含一个整数，表示最少需要的畜栏数；接下来 N 行，第 i+1 行描述了第 i 头牛所被分配的畜栏编号（从1开始）。 [样例输入] 5 1 10 2 4 3 6 5 8 4 7 [样例输出] 4 1 2 3 2 4 [思路] 所有奶牛都必须挤奶。到了一个奶牛的挤奶开始时间，就必须为这个奶牛找畜栏。因此按照奶牛的开始时间逐个处理它们，是必然的。 S(x)表示奶牛x的开始时间。E(x)表示x的结束时间。对E(x), x可以是奶牛，也可以是畜栏。畜栏的结束时间，就是正在其里面挤奶的奶牛的结时间。同一个畜栏的结束时间是不断在变的。 把所有奶牛按开始时间从小到大排序。 为第一头奶牛分配一个畜栏。 依次处理后面每头奶牛i。处理i 时，考虑已分配畜栏中，结束时间最早的畜栏x。 若E(x) 若E(x) >= S(i)，则分配新畜栏y，记E(y) = E(i)。 直到所有奶牛处理结束。 需要用优先队列存放已经分配的畜栏，并使得结束时间最早的畜栏始终位于队列头部。 [参考代码] #include #include #include using namespace std; // 奶牛结构体 struct Cow { int s; // 开始挤奶时间 int e; // 结束挤奶时间 int no; // 奶牛编号 friend bool operator s2.end; } }; int main(void) { int n; scanf(\"%d\", &n); for(int i=0; i pQueue; for(int i=0; i 5.6 放置雷达 [题面] 假设海岸是一条直线。陆地在海岸的一侧，海洋在海岸的另外一侧。每个岛屿都是海边的一个点。雷达装置只能安装在海岸上，当一个雷达装置到岛屿的距离不超过 d （整数），则认为该雷达覆盖了该 岛屿。 使用笛卡尔积坐标系，定义海岸是 x 轴，海洋位于 x 轴上方，陆地位于 x 轴下方。给定海洋中每个岛屿的位置，并告知雷达装置的覆盖距离，请编写程序求出至少需要多少个雷达装置才能够覆盖所有的岛屿。 [输入] 输入包含多组测试用例。 每组测试用例的第一行都包含两个整数 n(1 \\leq n \\leq 1000) 和 d，其中 n 是海洋中的岛屿数量，d 是雷达设备的覆盖距离。之后 n行，每行包含两个表示每个岛的位置坐标（x, y）的整数。 以空白行分隔多组测试用例。输入一组0时表示输入结束。 [输出] 对于每组测试用例进行输出，一行由测试用例编号和所需的最少雷达安装数组成。“ -1”意味着在这种情况下没有解决方案。 [样例输入] 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 [样例输出] Case 1: 2 Case 2: 1 [思路] 对每个岛屿P，可以算出覆盖它的雷达必须位于x轴上的区间 [P_s,P_e]。如果有雷达位于某个x轴区间 [a,b]，称该雷达覆盖此区间。 问题转换为，至少要在x轴上放几个雷达（点），才能覆盖全部区间 [P1_s,P1_e]，[P2_s,P2_e] ... [Pn_s,Pn_e] 。 如果可以找到一个雷达同时覆盖多个区间，那么把这多个区间按终点坐标从小到大排序，则第一个区间（终点最靠左的）的终点，就能覆盖所有区间。 有了这个结论，就可以只挑区间的终点来放置雷达了。 [参考代码] #include #include #include using namespace std; struct Range { double l, r; bool operator d) noAnswer=1; } if(noAnswer) { printf(\"Case %d: %d\\n\", k++, -1); continue; } sort(arr, arr+n); int count = 1; double maxR = arr[0].r; for(int i=0; i maxR) { maxR = arr[i].r; count++; } } printf(\"Case %d: %d\\n\", k++, count); } return 0; } 5.7 钓鱼 [题面] John要去钓鱼了。他共有 h \\; (1 \\leq h \\leq 16) 个小时的时间来进行钓鱼，并且钓鱼区域有 n \\; (2 \\leq n \\leq 25) 个湖泊可以通过一条单向路径到达。John从1号湖泊开始钓鱼，从任何位置结束钓鱼。他只能从一个湖泊到另一个湖泊单向行走，只要他愿意他可以不在任何一个湖上停留。对于每个 i = 1，...，n-1 ，从 湖泊i 到 湖泊i + 1 耗时 ti \\; (0 个时间片（每个时间片5分钟）。例如，t3 = 4 意味着从 湖泊3 到 湖泊4 需要20分钟。 为计划完成他的钓鱼之旅，John收集了关于湖泊的信息。对于每个 湖泊i，已知在最初5分钟内将钓到鱼的数量表示为 fi \\; (fi \\geq 0)。每钓鱼5分钟，下一个5分钟间隔内预期钓到鱼的数量将以恒定的 di \\; (di \\geq 0) 的速率减少。如果预计在一个间隔中钓到鱼的数量小于或等于 di，则在下一个间隔中当前湖泊中将不再有鱼上钩。为了简化计划，John假设其他人都不会在湖边钓鱼，以影响他的钓鱼数量。 编写程序帮助John完成他的钓鱼之旅，以最大程度地提高预期钓鱼数量。在每个湖上花费的分钟数必须是5的倍数。 [输入] 输入中将提供多组测试用例。 每组测试用例第一行输入 n ，第二行输入 h 。接下来一行中输入 n 个整数表示 fi \\; (1 \\leq i \\leq n)，然后一行输入 n 个整数表示 di \\; (1 \\leq i \\leq n)，最后一行 n-1 个整数表示 ti \\; (1 \\leq i \\leq n-1)。 如果输入 n = 0 时表示输入结束。 [输出] 对于每组测试用例，请打印每个湖泊所花费的分钟数（以逗号分隔，逗号后面加一个空格），以使计划达到预期的最大捕捞量（即使计划超过80个字符，也应将整个计划打印在一行上）。之后一行输出预期最大钓鱼数量。 如果存在多个计划，如果有多种方案，则优先选择在第一个湖泊呆时间最长的。如果还有多种，则 优先选择在第二个湖泊呆的时间最长的，依此类推。 在每组输出之间插入空白行。 [样例输入] 2 1 10 1 2 5 2 4 4 10 15 20 17 0 3 4 3 1 2 3 4 4 10 15 50 30 0 3 4 3 1 2 3 0 [样例输出] 45, 5 Number of fish expected: 31 240, 0, 0, 0 Number of fish expected: 480 115, 10, 50, 35 Number of fish expected: 724 [思路] 本题难点是走路时间可多可少，不确定到底该花多长时间纯钓鱼才最好（可能有好湖在很右边）。 可以通过枚举最终停下来的湖，将方案分成 n 类。每类方案的走路时间就是确定的。在每类方案里找最优解，然后再优中选优。 贪心策略： 在确定停下来的湖是 x 的情况下，假定纯钓鱼时间是 k 个时间片。 用三元组 (F,i,j) (1\\leq i \\leq x, 1 \\leq j \\leq k) 表示 湖泊i 的 第j个时间片 能够钓的鱼的数目是 F 。 将所有的 (F,i,j)（共x*k个）按 F 值从大到小排序，选前 k 个，就构成了最佳钓鱼方案。 [参考代码] #include #include #include using namespace std; // 湖泊信息结构体 struct Lake { int fi; // 池塘初始5分钟内钓鱼数量 int id; // 池塘编号 int di; // 池塘每5分钟钓鱼衰减数量 // 大根堆 friend bool operator r.id; return l.fi queue; for(int j=0; j0; --time) { Lake lake = queue.top(); queue.pop(); tempFish += lake.fi; lake.fi -= lake.di; if(lake.fi maxFish) { maxFish = tempFish; for(int j=0; j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-24 22:47:47 "},"slides/ch06.html":{"url":"slides/ch06.html","title":"第六章：深度优先搜索","keywords":"","body":"第6章 深度优先搜索 在图上寻找路径 在图上如何寻找从1到8的路径？ 一种策略：只要能发现没走过的点，就走到它。有多个点可走就随便挑一个，如果无路可走就回退，再看有没有没走过的点可走。 运气好：[1] -> [2] -> [4] -> [8] 运气一般：[1] -> [2] -> [4] -> [5] -> [6] -> [8] 运气坏：[1] -> [3] -> [7] -> [9] => [7] => [3] -> [5] -> [6] -> [8]（双线箭头表示回退） 不连通的图，无法从节点1走到节点8。 完整的尝试过程可能为：[1] -> [2] -> [4] -> [3] -> [7] => [3] => [4] => [2] -> [9] => [2] => [1] 结论：不存在从1到8的路径。得出这个结论之前，一定会把从1出发能走到的点全部都走过。 从起点出发，走过的点要做标记，发现有没走过的点，就随意挑一个往前走，走不了就回退，此种路径搜索策略就称为“深度优先搜索”，简称“深搜”。 其实称为“远度优先搜索”更容易理解些。因为这种策略能往前走一步就往前走一步，总是试图走得更远。所谓远近(或深度），就是以距离起点的步数来衡量的。 判断从V出发是否能走到终点 bool Dfs(V) { if(V为终点) return true; 将V标记为旧点; 对和V相邻的每个新节点U { if(Dfs(U) == true) return true; } return false; } int main(void) { 将所有点都标记为新点; 起点 = 1; 终点 = 8; printf(\"%s\\n\", Dfs(起点) ? \"Yes\" : \"No\"); return 0; } 判断从V出发是否能走到终点，如果能输出路径 Node path[MAX_LEN]; // MAX_LEN取节点总数即可 int depth; bool Dfs(V) { if(V为终点) { path[depth] = V; return true; } 将V标记为旧点; path[depth] = V; ++depth; 对和V相邻的每个新节点U { if(Dfs(U) == true) return true; } --depth; return false; } int main(void) { 将所有点都标记为新点; depth = 0; if(Dfs(起点)) { for(int i = 0;i 遍历图上所有节点 Dfs(V) { 将V标记为旧点; 对和V相邻的每个新点U { Dfs(U); } } int main(void) { 将所有点都标记为新点; while(在图中能找到新点k) Dfs(k); } 图的表示方法 -- 邻接矩阵 用一个二维数组G存放图，G[i][j]表示节点i和节点j之间边的情况（如有无边，边方向，权值大小等) 。 遍历复杂度：O(n^2)。 （n为节点数目） 图的表示方法 -- 邻接表 每个节点V对应一个一维数组（vector），里面存放从V连出去的边，边的信息包括另一顶点，还可能包含边权值等。 遍历复杂度：O(n+e)。 （n为节点数目，e为边数目） 6.1 城堡问题 [题面] 1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####---#####---#---#####---# 2 # # | # # # # # #---#####---#####---#####---# 3 # | | # # # # # #---#########---#####---#---# 4 # # | | | | # # ############################# # = Wall | = No wall - = No wall 上图是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成 m \\times n（m \\leq 50，n \\leq 50）个方块，每个方块可以有0~4面墙。 [输入] 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字（0 \\leq p \\leq 50）描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块（1,1）的南墙同时也是方块（2,1）的北墙。输入的数据保证城堡至少有两个房间，数据保证城堡四周都是墙。 [输出] 城堡的房间数、城堡中最大房间所包括的方块数。结果显示在标准输出设备上。 [样例输入] 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 [样例输出] 5 9 [思路] 把方块看作是节点，相邻两个方块之间如果没有墙，则在方块之间连一条边，这样城堡就能转换成一个图。 求房间个数，实际上就是在求图中有多少个极大连通子图。 一个连通子图，往里头加任何一个图里的其他点，就会变得不连通，那么这个连通子图就是 极大连通子图。 对每一个房间，深度优先搜索，从而给这个房间能够到达的所有位置染色。最后统计一共用了几种颜色，以及每种颜色的数量。 如题目描述示例中，图完色可知一共有5个房间，最大的房间（1）占据9个格子。 ############################# # 1 | 1 # 2 | 2 # 3 | 3 | 3 # #####---#####---#---#####---# # 1 # 1 | 1 # 2 # 3 # 4 # 3 # #---#####---#####---#####---# # 1 | 1 | 1 # 5 # 3 # 5 # 3 # #---#########---#####---#---# # 1 # 5 | 5 | 5 | 5 | 5 # 3 # ############################# [参考代码] #include int R,C; // 行列数 int rooms[60][60]; int color[60][60] = {0}; int maxRoomArea = 0, roomNum = 0; int totalRoomArea; void dfs(int i, int j) { if(color[i][j]) return; ++totalRoomArea; color[i][j] = roomNum; if(!(rooms[i][j]&1)) dfs(i, j-1); // 向西 if(!(rooms[i][j]&2)) dfs(i-1, j); // 向北 if(!(rooms[i][j]&4)) dfs(i, j+1); // 向东 if(!(rooms[i][j]&8)) dfs(i+1, j); // 向南 } int main(void) { scanf(\"%d%d\", &R, &C); for(int i=1; imaxRoomArea ? totalRoomArea : maxRoomArea; } } } printf(\"%d\\n\", roomNum); printf(\"%d\\n\", maxRoomArea); } 6.2 踩方格 [题面] 有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设： a. 每走一步时，只能从当前方格移动一格，走到某个相邻的方格上； b. 走过的格子立即塌陷无法再走第二次； c. 只能向北、东、西三个方向走； 请问：如果允许在方格矩阵上走 n 步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。 [输入] 允许在方格上行走的步数 n（n \\leq 20） [输出] 计算出的方案数量。 [样例输入] 2 [样例输出] 7 [思路] 递归从(i,j) 出发，走n步的方案数，等于以下三项之和： 从(i+1,j)出发，走n-1步的方案数。前提：(i+1,j)还没走过 从(i,j+1)出发，走n-1步的方案数。前提：(i,j+1)还没走过 从(i,j-1)出发，走n-1步的方案数。前提：(i,j-1)还没走过 [参考代码] #include int visited[30][50] = {0}; int ways(int i, int j, int n) { if( n == 0) return 1; int num = 0; visited[i][j] = 1; if(!visited[i][j-1]) num += ways(i, j-1, n-1); if(!visited[i][j+1]) num += ways(i, j+1, n-1); if(!visited[i+1][j]) num += ways(i+1, j, n-1); visited[i][j] = 0; return num; } int main(void) { int n; scanf(\"%d\", &n); printf(\"%d\\n\", ways(0,25,n)); return 0; } 6.3 古代象形文字 [题面] 人类为了了解早期文明，考古学家经常研究古代语言书写的文本。其中有一种语言是在3000多年前古埃及使用的象形文字。下图中显示了六个象形文字及其名称。需要你编写一个程序来识别这六个字。 [输入] 每组数据包含一个 H 行 W 列的字符矩阵（H \\leq 200, \\; W \\leq 50），每个字符为4个相邻像素点的十六进制（例如，10011100 对应的字符就是 9c）。转化为二进制后 1 表示黑点，0 表示白点。 输入满足： 不会出现上述6种符号之外的其它字符。 输入至少包含一个符号，且每个黑像素都属于一个符号。 每个符号都是一个四连块，并且不同符号不会相互接触，也不会相互包含。 如果两个黑像素有公共顶点，则它们一定有一个相同的相邻黑像素（有公共边）。 符号的形状一定和上图中的图形拓扑等价（可以随意拉伸但不能拉断）。 输入 两个 0 时表示输入结束。 [输出] 对于每个测试用例，输出\"Case N: \"，N为用例号，后面接在图像中识别出的象形文字组成的字符串，每个象形文字只输出一个代表其含义的字母。 Ankh : A Wedjat : J Djed : D Scarab : S Was : W Akhet : K 每个输出字符串中字符按字典序排序。例如下图输出 AKW 。 下图输出 AAAAA 。 [样例输入] 100 25 0000000000000000000000000 0000000000000000000000000 ...(50 lines omitted)... 00001fe0000000000007c0000 00003fe0000000000007c0000 ...(44 lines omitted)... 0000000000000000000000000 0000000000000000000000000 150 38 00000000000000000000000000000000000000 00000000000000000000000000000000000000 ...(75 lines omitted)... 0000000003fffffffffffffffff00000000000 0000000003fffffffffffffffff00000000000 ...(69 lines omitted)... 00000000000000000000000000000000000000 00000000000000000000000000000000000000 0 0 本章最后准备了本题的测试数据。 [样例输出] Case 1: AKW Case 2: AAAAA [思路] 根据题意，需要寻找在“随意拉伸”时还不会改变的“特征量”，通过计算和比较“特征量”完成识别。 题目说过，每个符号都是一个四连块，即所有黑点都连在一起，而中间有一些白色的“洞”。数一数就能发现，题目表中的6个符号从左到右依次有1，3，5，4，0，2个洞，各不相同。这样，只需要数一数输入的符号有几个“白洞”，就能准确地知道它是哪个符号了。 [参考代码] #include #include #include #include using namespace std; int H, W; int pic[210][210]; // 存储图片信息数组 int cnt = 0; // 象形文字个数 int ans[50]; // ans[i] 表示第i个象形文字内部洞的数量 // id[i] 表示i个洞的象形文字对应的字母 char id[6] = {'W', 'A', 'K', 'J', 'S', 'D'}; // 预处理，将象形文字外面的像素全置为-1 void dfs_pre(int i, int j) { if(i=H || j=4*W) return; if(pic[i][j] == 0) { pic[i][j] = -1; dfs_pre(i-1, j); dfs_pre(i+1, j); dfs_pre(i, j-1); dfs_pre(i, j+1); } } // dfs 象形文字内部空白区域 void dfs2(int i, int j) { if(i=H || j=4*W) return; if(pic[i][j] == 0) { pic[i][j] = -1; dfs2(i-1, j); dfs2(i+1, j); dfs2(i, j-1); dfs2(i, j+1); } } // dfs 象形文字线条本身，count表示第几个象形文字 void dfs1(int i, int j, int count) { if(i=H || j=4*W) return; // 遇到外部边界或者已经处理过 if (pic[i][j] == -1) return; // 遇到象形文字本身 else if(pic[i][j] == 1) { pic[i][j] = -1; dfs1(i-1, j, count); dfs1(i+1, j, count); dfs1(i, j-1, count); dfs1(i, j+1, count); } // 遇到象形文字内部 else if (pic[i][j] == 0) { // 记录象形文字内部洞个数 ans[count]++; dfs2(i, j); } } int main(void) { int kase = 0; while(~scanf(\"%d%d\", &H, &W) && H && W) { // 初始化数组 fill(ans, ans+50, 0); // 初始化象形文字个数 cnt = 0; // 读取数据，并将十六进制还原成1/0 for(int i=0; i> s; for(int j=0; j> 3 & 1; pic[i][j*4+1] = t >> 2 & 1; pic[i][j*4+2] = t >> 1 & 1; pic[i][j*4+3] = t & 1; } } // 预处理，将象形文字外部的像素置为-1 for(int i=0; i 6.4 数独游戏 [题面] 数独是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个3*3宫内的数字均含1-9，不重复。 每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。 芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”，但对会使用计算机编程的你来说，恐怕易如反掌了。 本题的要求就是输入数独题目，程序输出数独的唯一解。 [输入] 第一行有一个数 n（0 ），表示有 n 组测试数据，每组测试数据是由一个9*9的九宫格构成，0表示对应的格子为空。 [输出] 针对每组样例，输出9行，每行9个数字表示数独的解，中间不需要添加其它字符。 [样例输入] 1 800000000 003600000 070090200 050007000 000045700 000100030 001000068 008500010 090000400 [样例输出] 812753649 943682175 675491283 154237896 369845721 287169534 521974368 438526917 796318452 [思路] 从左上角开始，通过对每一个没有填数的格子进行1到9的遍历，然后通过约束函数来判断该该格子的填数是否符合规则，若符合就递进到下一个（即右边的格子），假若下一个格子已超出右边界，则递进到下一行的第0个格子处，依此类推，直到填完最后一个格子即完成数独的解！ [参考代码] #include #include #include using namespace std; int p[9][9]; int fag = 0; // 打印答案 void print_ans() { for(int i=0; i> line; for(int j=0; j 6.5 困难的串 [题面] 如果一个字符串包含两个相邻的重复子串，则称它是”容易的串“，其他串成为”困难的串“。 例如：\"BB\"，\"ABCDACABCAB\"，\"ABCDABCD\"都是”容易的串“，\"D\"，\"DC\"，\"ABDAB\"，\"CBABCBA\"都是”困难的串“。 [输入] 本题有多组测试用例。输入正整数 n，L。表示要输出由前 L 个字符（大写英文字母）组成的，字典序第 n 小的“困难的串”（字典序）。 例如对于 L = 3，前 n = 7 个”困难的串“为： A AB ABA ABAC ABACA ABACAB ABACABA 输入两个0时表示终止。 [输出] 由于每个串都可能很长（串最大长度80），请将其分为4个字符一组，每组字符使用空格隔开。如果当前用例输出字符组超过16个，在新的一行输出第17组字符。 “困难的串”输出完后在新的一行输出“困难的串”的长度。 因此对于 L = 3，n = 7 输出为： ABAC ABA 7 [样例输入] 30 3 0 0 [样例输出] ABAC ABCA CBAB CABA CABC ACBA CABA 28 [思路] 根据题意可知，“困难的串”去掉最后一个字符之后，也必然是一个“困难的串”。只需在“困难的串”末尾尝试加入一个字符，然后判断其是否为“困难的串”即可。 此外在判断“困难的串”时，根据前面分析，则只需要判断最后一个字符所在子串即可。 [参考代码] #include #include int N, L; int cnt; int is_hard(char * s) { char temp[100]; int len = strlen(s); for(int i=1; i 6.6 ROADS [题面] 编号为1到N的N个城市通过单向道路连接。每条道路都有两个属性：道路长度和道路通行费。 Bob和Alice共同居住在城市1，当发现Alice在他们喜欢的纸牌游戏中作弊后，Bob决定与她分手，并想要尽快的搬到城市N，不过他现在非常的缺钱。 我们需要帮助Bob找到城市1到城市N的最短路径，并且在他能够负担的起的范围内。 [输入] 第一行输入包含一个整数K，0 \\leq K \\leq 10000，表示Bob可以花费的最大钱数。 第二行包含一个整数N，2 \\leq N \\leq 100，表示城市的数量。 第三行包含一个整数R，1 \\leq R \\leq 10000，表示道路的数量。 接下来R行是通过空格隔开的整数S，D，L和T，用来描述一条道路： S表示道路的起点城市，1 \\leq S \\leq N。 D表示道路的目的城市，1 \\leq D \\leq N。 L表示道路的长度，1 \\leq L \\leq 100。 T表示道路的通行费，0 \\leq T \\leq 100。 请注意，不同的道路可能具有相同的起点城市和目的城市。 [输出] 输出一行包含一个整数，表示从城市1到城市N的最短路径长度，其通行费应小于或等于K。 如果满足要求的路径不存在，则输出-1。 [样例输入] 5 6 7 1 2 2 3 2 4 3 3 3 4 2 4 1 3 4 1 4 6 2 1 3 5 2 0 5 4 3 2 [样例输出] 11 [思路] 从城市1开始深度优先遍历整个图，找到所有能过到达城市N的走法，选一个最优的。 根据思路写完程序，在OJ提交时结果却显示超时，此时需要对搜索算法进行剪枝。题目链接 可行性剪枝： 如果当前条件不合法就不再继续搜索，直接return。这是非常好理解的剪枝，搜索初学者都能轻松地掌握，而且也很好想。一般的搜索都会加上。 最优性剪枝： 如果当前条件所创造出的答案必定比之前的答案大，那么剩下的搜索就毫无必要，甚至可以剪掉。 从本题来看： 如果当前已经找到的最优路径长度为L ,那么在继续搜索的过程中，总长度已经大于等于L的走法，就可以直接放弃，不用走到底了。 如果到达某个状态A时，发现前面曾经也到达过A，且前面那次到达A所花代价更少，则剪枝。这要求保存到达状态A的到目前为止的最少代价。 用midL[k][m] 表示：走到城市k时总过路费为m的条件下，最优路径的长度。若在后续的搜索中，再次走到k时，如果总路费恰好为m，且此时的路径长度已经超过midL[k][m]，则不必再走下去了。 [参考代码] #include #include #include using namespace std; struct Road { int e; // 道路终点 int l; // 道路长度 int t; // 道路花费 }; int K; // 总钱数 int N; // 城市数量 int R; // 单向道路条数 int minLen = INT_MAX; // 最小长度 int totalLen = 0; // 当前总长度 int totalCost = 0; // 当前成本 // 记录城市是否走过的标识数组 int visited[110] = {0}; // minL[i][j] 表示 从起点走到城市i时在总花费j的条件下， // 起点到城市i目前的最优路径长度 int minL[110][10010]; // 记录道路信息的邻接表 vector> adj(110); void dfs(int s) { // 已经到达终点，记录最短路径长度 if(s == N) { minLen = minLen K) continue; // 到达目的城市的路径长度已经大于之前的最短路径 if(totalLen + r.l >= minLen) continue; // 当前到达目的城市已经走过的路径长度大于之前到达目的城市 // 走过的路径长度（在花费相同的情况下） if(totalLen + r.l >= minL[r.e][totalCost+r.t]) continue; minL[r.e][totalCost+r.t] = totalLen + r.l; totalLen += r.l; totalCost += r.t; visited[r.e] = 1; dfs(r.e); totalLen -= r.l; totalCost -= r.t; visited[r.e] = 0; } } int main(void) { scanf(\"%d %d %d\", &K, &N, &R); for(int i=0; i 6.7 生日蛋糕 [题面] 7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为 Nπ 的 M 层生日蛋糕，每层都是一个圆柱体。 设从下往上数第i（1 \\leq i \\leq M）层蛋糕是半径为 Ri , 高度为 Hi 的圆柱。当 i 时，要求 Ri > Ri+1且Hi > Hi+1。 由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 Q 最小。 令 Q = Sπ 。 请编程对给出的 N 和 M ，找出蛋糕的制作方案（适当的 Ri 和 Hi 的值），使 S 最小。 （除 Q 外，以上所有数据皆为正整数） [输入] 有两行，第一行为 N（N \\leq 10000），表示待制作的蛋糕的体积为 Nπ ；第二行为M（M \\leq 20），表示蛋糕的层数为 M 。 [输出] 仅一行，是一个正整数 S（若无解则 S = 0）。 [样例输入] 100 2 [样例输出] 68 [提示] 圆柱公式 体积 V = πR^2H 侧面积 A' = 2πRH 底面积 A = πR^2 [思路] 深度优先搜索，枚举什么？ 枚举每一层可能的高度和半径。 如何确定搜索范围？ 底层蛋糕的最大可能半径和最大可能高度。 搜索顺序，哪些地方体现搜索顺序？ 从底层往上搭蛋糕，而不是从顶层往下搭。 如何剪枝？ 剪枝1：搭建过程中发现已建好的面积已经超过目前求得的最优表面积，或者预见到搭完后面积一定会超过目前最优表面积，则停止搭建。（最优性剪枝） 剪枝2：搭建过程中预见到再往上搭，高度已经无法安排，或者半径已经无法安排，则停止搭建。（可行性剪枝） 剪枝3：搭建过程中发现还没搭的那些层的体积，一定会超过还缺的体积，则停止搭建。（可行性剪枝） 剪枝4：搭建过程中发现还没搭的那些层的体积，最大也到不了还缺的体积，则停止搭建。（可行性剪枝） [参考代码] #include #include #include int N, M; int minArea = INT_MAX; int totalArea; // minSArr[i] : 第i层到第1层最小可能的侧面积和 int minSArr[25]; // minVArr[i] : 第i层到第1层最小可能的体积和 int minVArr[25]; void dfs(int v, int m, int r, int h) { if(m==0) { if(!v) minArea = minArea=minArea) return; // [剪枝]根据当前表面积搭完后表面积不会小于等于最小表面积 if(totalArea+minSArr[m] >= minArea) return; // [剪枝]根据当前体积搭完后总体积一定大于给定体积 if(minVArr[m] > v) return; // [剪枝]根据当前体积搭完后总体积一定小于给定体积 int sum=0; for(int i=r,j=h, k=m; k>0&&i>0&&j>0; --i,--j,--k) sum += i*i*j; if(sum =m; --rr) { if(m==M) totalArea = rr * rr; for(int hh=h; hh>=m; --hh) { totalArea += 2*rr*hh; dfs(v-rr*rr*hh, m-1, rr-1, hh-1); totalArea -= 2*rr*hh; } } } int main(void) { for(int i=1; i 6.3 古代象形文字 - 测试数据 [样例输入] 6 2 00 7c 44 7c 30 00 6 25 0000000000000000000000000 0000000000000000000000000 00001fe0000000000007c0000 00003fe0000000000007c0000 0000000000000000000000000 0000000000000000000000000 10 3 000 778 548 748 578 700 000 7f0 1e0 000 16 2 00 7e 42 7e 42 7e 42 7e 42 7e 42 7e 00 00 4a 00 16 1 0 1 3 2 8 e f 5 7 6 4 c d 9 b a 9 2 00 7e 42 7e 42 7e 42 7e 00 43 2 00 7e 00 7e 42 7e 42 7e 42 7e 00 7e 42 7e 00 7e 42 7e 42 7e 00 7e 42 7e 42 7e 42 7e 42 7e 00 7e 42 7e 42 7e 42 7e 42 7e 42 7e 00 200 50 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 10000000000000000000000000000000000000000000000000 100 25 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 00000f8000000000000000000 00001fe000000000000000000 00007ff000000000000000000 00007ff800000000000000000 0000f8f800000000000000000 0001f07c00000000000000000 0001e03c00000000001800000 0001e01c00000000003c00000 0001c01c00000000007c00000 0003c01e0000000000f800000 0003c01e0000000001f000000 0001c01c0000000003f000000 0001c01c0000000007e000000 0001e01c000000000fc000000 0001e03c000000001fc000000 0000e03c000000001fc000000 0000f038000000003ff000000 0000f078000000003ff800000 00007870000000007ff800000 000038f0000000007cfc00000 00003ce0000000007c7c00000 00781fc0f0000000f87c00000 007ffffff0000000f07c00000 007ffffff0000000f07c00000 007ffffff0000001f07c00000 007ffffff0000000e03e00000 007fcf81f0000000603e00000 00000f8000000000003e00000 00000f8000000000003e00000 00000f8000000000003e00000 00000f8000000000001e00000 00000f8000000000001f00000 00000fc000000000001f00000 00000fc000000000001f00000 00000fc000000000001f00000 00000fc000000000000f00000 00001fc000000000000f80000 00001fc000000000000f80000 00001fc000000000000f80000 00001fc000000000000f80000 00001fe000000000000f80000 00001fe000000000000780000 00001fe0000000000007c0000 00001fe0000000000007c0000 00003fe0000000000007c0000 00003fe0000000000007c0000 00003fe0000000000007c0000 00003fe0000c00000003c0000 00000000003ff0000003c0000 00000000007ff8000003e0000 0000000001fffc000003e0000 0000000003e03f000003e0000 0000000007c00f000003e0000 000000000f0003800003f0000 000000000e0001c00003fc000 000000001c0001e00007fe000 000000003c0000e0000fff000 000000073c000070000fdf000 0000001ff8000070001f0f800 0000001ff8000070001e07800 0000003cf0000078001e03800 0000003870000033001e03800 000000307800003fc01e03800 000000703800007fe00e03800 000000703800007ce00e03800 000000703c000078700703800 000000701e0000f0700701000 000000701e0000e0700300000 000000700f0001c0700000000 0000006007800380600000000 000000e003e00700600000000 000000e001fe7e00600000000 000000e000fffc00e00000000 000000e0000ff000e00000000 000000f800038000e00000000 000000fff0000000e00000000 000000fffff00000e00000000 00000003ffffe000c00000000 0000000007ffffc0c00000000 000000000007ffffc00000000 0000000000000fffc00000000 000000000000001fc00000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 0000000000000000000000000 150 38 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000003000000000 00000f80000000001fff000000007800000000 00001fe0000000007fff80000000ff00000000 00007ff000000000ffffe0000001ff80000000 00007ff800000003fffff0000001fffc000000 0000f8f800000007fffffc000001fffe000000 0001f07c0000000ffffffe000000ffff000000 0001e03c0000001fffffff000000ffff800000 0001e01c0000003fffffff0000007fffc00000 0001c01c0000003fffffff8000007fefc00000 0003c01e0000007fffffffc000003f83c00000 0003c01e000000ffffffffc000001f81e00000 0001c01c000000fffc0fffe000001f01e00000 0001c01c000001fff003ffe000000f01e00000 0001e01c000001ffe001fff000000f00e00000 0001e03c000003ffc0007ff000001e00f00000 0000e03c000003ff80007ff800001e00f00000 0000f038000007ff80003ff800001e00f00000 0000f078000007ff00003ff800001e00f00000 00007870000007ff00001ffc00000e00e00000 000038f000000fff00001ffc00000e00e00000 00003ce000000ffe00000ffc00000e00e00000 00781fc0f0000ffe00000ffc00000f00e00000 007ffffff0000ffc00000ffc00000f01e00000 007ffffff0000ffc00000ffc00000f01e00000 007ffffff0000ffc00000ffc00000701c00000 007ffffff0000ffc00000ffc00000781c00000 007fcf81f0000ffc000007fc00000783c00000 00000f8000000ffc000007fc00000383800000 00000f8000000ffc000007fc000003c7800000 00000f8000000ffc000007fc000001c7800000 00000f8000000ffc000007fc000001e7000000 00000f8000000ffc000007fc000200ef008000 00000fc000000ffc00000ffc0003f8fe3f8000 00000fc000000ffc00000ffc0003ffffff8000 00000fc000000ffc00000ffc0003ffffff8000 00000fc000000ffc00000ffc0003ffffff8000 00001fc000000ffc00000ffc0003ffffff8000 00001fc0000007fe00000ff80003ffffff8000 00001fc0000007fe00000ff80003fffdff8000 00001fc0000007fe00000ff80003c03c000000 00001fe0000007ff00001ff80000007c000000 00001fe0000003ff00001ff00000007c000000 00001fe0000003ff00001ff00000007c000000 00001fe0000001ff80003ff00000007c000000 00003fe0000001ff80003fe00000007c000000 00003fe0000001ff80003fe00000007c000000 00003fe0000000ffc0007fe00000007c000000 00003fe0000000ffc0007fc00000007c000000 000000000000007fe0007fc00000007c000000 000000000000007fe000ff800000007c000000 000000000000007ff001ff800000007c000000 000000000000003ff001ff800000007c000000 000000000000001ff803ff000000007c002000 000000000000001ff803ff000000007c006000 000000000000000ffc07fe000000007c006000 000000000000000ffc0ffc000000007c00c000 000000000000000ffe0ffc000000003e01c000 0000000000000007ff0ff8000000003f03c000 0000000000000003ff1ff0000000003f8f8000 0000000003c00001ffbff00000f0001fff8000 0000000003ffc001ffffe0007ff0000fff8000 0000000003fffff1ffffe3fffff00007ff8000 0000000003fffffffffffffffff00001ff0000 0000000003fffffffffffffffff00000ff0000 0000000003fffffffffffffffff000007f0000 0000000003fffffffffffffffff000001e0000 0000000003fffffffffffffffff000000e0000 0000000003fffffffffffffffff00000020000 0000000003fffffffffffffffff00000000000 0000000003fffffffffffffffff00000000000 0000000003fffffffffffffffff00000000000 0000000003fffffffffffffffff00000000000 0000000003fffffffffffffffff00000000000 0000000003fffffffffffffffff00000000000 0000000003fffffc1ffe0007fff00000000000 0000000003ff80000ffe000000f00000000000 00000000038000000ffe000000000000000000 00000000000000001fff000000000000000000 00000000000000001fff000000000000000000 00000000000000001fff000000000000000000 00000000000000001fff000000000000000000 00000000000000001fff000000000000000000 00000000000000001fff000000000000000000 00000000000000003fff000000000000000000 00000000000000003fff000000000000000000 00000000000000003fff0000000fc000000000 000000000fe000003fff8000003ff000000000 000000003ffc00003fff8000007ffc00000000 00000000fffe00003fff800000fcfc00000000 00000001f01f00003fff800001f03e00000000 00000003e00f80003fff800003e01f00000000 00000003e00780003fff800003e00f00000000 00000003e00780003fff800003c00f00000000 00000003e00f80003fff800003c00f00000000 00000001f00f00007fff800003c00f00000000 00000000f81e00007fffc00003e00f00000000 000000007c3c00007fffc00001e01e00000000 000000003e7800007fffc00000f01e00000000 000000fffffffe007fffc00000f03c00000000 000000fffffffe007fffc00000787800000000 000000fffffffe007fffc000003cf000000000 0000000007c000007fffe000f81fe07c000000 0000000007e000007fffe000fffffffc000000 0000000007e000007fffe000fffffffc000000 000000000fe000007fffe000fffffffc000000 000000000ff00000ffffe000ffc7c0fc000000 000000000ff00000ffffe0000007c000000000 000000001ff00000ffffe000000fc000000000 000000001ff00000ffffe000000fc000000000 000000001ff80000ffffe000000fc000000000 000000001ff80000ffffe000000fc000000000 000000003ff80001ffffe000000fe000000000 000000003ff80001ffffe000000fe000000000 0000000000000001fffff000001fe000000000 0000000000000001fffff000001fe000000000 0000000000000001fffff000001fe000000000 0000000000000001fffff000001ff000000000 0000000000000001fffff000001ff000000000 0000000000000001fffff000001ff000000000 0000000000000001fffff000003ff000000000 0000000000000001fffff000003ff000000000 0000000000000001fffff000003ff000000000 0000000000000001fffff80000000000000000 0000000000000003fffff80000000000000000 0000000000000003fffff80000000000000000 0000000000000003fffff80000000000000000 0000000000000003fffff80000000000000000 0000000000000003fffff80000000000000000 0000000000000003fffff80000000000000000 0000000000000003fffff80000000000000000 0000000000000003fffffc0000000000000000 0000000000000003fffffc0000000000000000 0000000000000007fffffc0000000000000000 0000000000000007fffffc0000000000000000 0000000000000007fffffc0000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 00000000000000000000000000000000000000 0 0 [样例输出] Case 1: A Case 2: WW Case 3: AKW Case 4: DWWW Case 5: AWW Case 6: J Case 7: ADJKSW Case 8: WWWWWWWWWWWWWWWWWWWW Case 9: AKW Case 10: AAAAA Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-24 22:47:47 "},"slides/ch07.html":{"url":"slides/ch07.html","title":"第七章：广度优先搜索","keywords":"","body":"第7章 广度优先搜索 7.1 抓住那头牛 总时间限制: 2000ms 内存限制: 65536kB [题面] 农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点 N(0 \\leq N \\leq 100000)，牛位于点 K(0 \\leq K \\leq 100000) 。农夫有两种移动方式： 1、从 X 移动到 X-1 或 X+1，每次移动花费一分钟 2、从 X 移动到 2*X ，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？ [输入] 两个整数，N 和 K 。 [输出] 一个整数，农夫抓到牛所要花费的最小分钟数。 [样例输入] 5 17 [样例输出] 4 [思路] 使用BFS思想，给节点分层。起点是第0层。从起点最少需n步就能到达的点属于第n层。 依层次顺序，从小到大扩展节点。把层次低的点全部扩展出来后，才会扩展层次高的点。 扩展时，不能扩展出已经走过的节点(要判重），这样可确保找到最优解，但是因扩展出 来的节点较多，且多数节点都需要保存，因此需要的存储空间较大，通常使用队列存节点。 假设农夫起始位于点3，牛位于5，即N=3，K=5，最右边是6。 第1层：2, 4, 6 第2层：1, 5 第3层：0 [参考代码] #include #include #include using namespace std; int N, K; const int MAXN = 100000; // 判重标记 visited[i]=1 表示i已经扩展过 int visited[MAXN+10]; struct Step { int x; // 位置 int steps; // 到达x所需的步数 Step(int xx, int s):x(xx),steps(s) { } }; queue q; // 队列 int main(void) { scanf(\"%d %d\", &N, &K); memset(visited, 0, sizeof(visited)); q.push(Step(N, 0)); visited[N] = 1; while(!q.empty()) { Step s = q.front(); q.pop(); if(s.x == K) { // 找到目标 printf(\"%d\\n\", s.steps); return 0; } else { if(s.x - 1 >= 0 && !visited[s.x-1]) { q.push(Step(s.x-1, s.steps+1)); visited[s.x-1] = 1; } if(s.x + 1 7.2 迷宫问题 总时间限制: 1000ms 内存限制: 65536kB [题面] 定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 [输入] 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 [输出] 左上角到右下角的最短路径，格式如样例所示。 [样例输入] 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 [样例输出] (0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (2, 3) (2, 4) (3, 4) (4, 4) [思路] 先将起始位置入队列，每次从队列拿出一个元素，扩展其相邻的4个元素入队列(要判重），直到队头元素为终点为止。队列里的元素需要记录了指向父节点（上一步）的指针。 队列不能用STL的queue或deque，需要自己实现。可通过一维数组实现，只需维护一个队头指针和队尾指针。 队列元素： struct { int x, y; int f; // 父节点在队列中的下标 }; [参考代码] #include int maze[5][5] = {0}; struct Node{ int x, y; int f; // 父节点在队列中的下标 } queue[30]; void print(int i) { if(i==-1) return; print(queue[i].f); printf(\"(%d, %d)\\n\", queue[i].x, queue[i].y); } int main(void) { for(int i=0; i0 && maze[n.x-1][n.y]!=1) { queue[tail].x = n.x-1; queue[tail].y = n.y; queue[tail].f = head; tail++; maze[n.x-1][n.y] = 1; } if(n.x0 && maze[n.x][n.y-1]!=1) { queue[tail].x = n.x; queue[tail].y = n.y-1; queue[tail].f = head; tail++; maze[n.x][n.y-1] = 1; } if(n.y 7.3 鸣人和佐助 总时间限制: 1000ms 内存限制: 65536kB [题面] 佐助被大蛇丸诱骗走了，鸣人在多少时间内能追上他呢？ 已知一张地图（以二维矩阵的形式表示）以及佐助和鸣人的位置。地图上的每个位置都可以走到，只不过有些位置上有大蛇丸的手下，需要先打败大蛇丸的手下才能到这些位置。鸣人有一定数量的查克拉，每一个单位的查克拉可以打败一个大蛇丸的手下。 假设鸣人可以往上下左右四个方向移动，每移动一个距离需要花费1个单位时间，打败大蛇丸的手下不需要时间。如果鸣人查克拉消耗完了，则只可以走到没有大蛇丸手下的位置，不可以再移动到有大蛇丸手下的位置。佐助在此期间不移动，大蛇丸的手下也不移动。 请问，鸣人要追上佐助最少需要花费多少时间？ [输入] 输入的第一行包含三个整数：M，N，T。代表M行N列的地图和鸣人初始的查克拉数量T。0 ，0 \\leq T 后面是M行N列的地图，其中@代表鸣人，+代表佐助。*代表通路，#代表大蛇丸的手下。 [输出] 输出包含一个整数R，代表鸣人追上佐助最少需要花费的时间。如果鸣人无法追上佐助，则输出-1。 [样例输入] 样例输入1 4 4 1 #@## **## ###+ **** 样例输入2 4 4 2 #@## **## ###+ **** [样例输出] 样例输出1 6 样例输出2 4 [思路] 状态定义为：（x, y, k) x : 鸣人所在的行 y : 鸣人所在的列 k : 鸣人查克拉数量 如果队头节点扩展出来的节点是有大蛇手下的节点，则其 k 值比队头的 k 要减掉1。如果队头节点的查克拉数量为0，则不能扩展出有大蛇手下的节点。 [参考代码] #include #include using namespace std; struct Node{ int x; int y; int k; // 剩余查克拉数 int t; // 花费时间 Node(int xx, int yy, int kk, int tt) :x(xx), y(yy), k(kk), t(tt) {} }; queue q; char maze[210][210];// 迷宫 int maxK[210][210]; // 到达某点时剩余最大查克拉数 // dir[i][j] 表示移动的方向 int dir[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int M; // 行数 int N; // 列数 int T; // 查克拉数 int ANS = -1; void bfs() { while(!q.empty()) { Node n = q.front(); q.pop(); if(maze[n.x][n.y] == '+') { ANS = n.t; break; } else { for(int i=0; i= M || yy = N) || maxK[xx][yy] >= n.k) continue; if(maze[xx][yy] == '#') { if(n.k > 0) { // 查克拉充足 q.push(Node(xx, yy, n.k-1, n.t+1)); maxK[xx][yy] = n.k-1; } } else { q.push(Node(xx, yy, n.k, n.t+1)); maxK[xx][yy] = n.k; } } } } } int main(void) { scanf(\"%d %d %d\", &M, &N, &T); // 读取数据并找到鸣人位置完成队列入队 // 同时初始化maxK数组 for(int i=0; i 7.4 Fire! [题面] Joe在迷宫里工作，非常不幸迷宫的某些地方着火了，而迷宫的所有者却没有制定相应的逃生计划。请帮助Joe逃脱迷宫。 已知Joe在迷宫中的位置以及迷宫哪些地方着火，您必须确定Joe是否可以在大火到达迷宫之前离开迷宫，以及他能最快离开迷宫的时间。 Joe每分钟可以走到上下左右4个方向的相邻格格子，而所有着火的地方每分钟也都会往四周蔓延（即如果某个空格与着火格有公共边，则下一分钟这个空格将着火）。迷宫中有一些障碍格，Joe和火都无法进入。当Joe走到一个迷宫的边界格子时，我们认为他已经出了迷宫。 [输入] 输入第一行为数据组数T。每组数据第一行为两个整数R和C（1 \\leq R, C \\leq 1000）。以下R行每行有C个字符，即迷宫。其中“#”表示墙和障碍物，“.”表示空地，“J”是Joe的初始位置（也是一个空地），“F”是着火格。每组数据的迷宫中恰好有一个格子是“J”。 [输出] 对于每组数据，输出走出迷宫的最短时间（单位：分钟）。如果无法走出迷宫，则输出 “IMPOSSIBLE”。 [样例输入] 2 4 4 #### #JF# #..# #..# 3 3 ### #J. #.F [样例输出] 3 IMPOSSIBLE [思路] 火是不会自动熄灭的，因此只要某个格子在某时刻起火了，那以后将一直如此。所以只需要预处理每个格子起火的时间，在BFS扩展节点的时候加一个判断，当到达新节点时该格子没有着火才真的把这个新节点加到队列中。 最后需要考虑一下如何求出每个格子起火的时间，其实这也是一个最短路问题，只不过起点不是一个，而是多个（所有的初始着火点）。这只需要在初始化队列时把所有着火点都放进去即可。 [参考代码] #include #include #include using namespace std; const int MAXN=1010; int N, M; // 迷宫地图 char maze[MAXN][MAXN]; // fireTime[i][j] 表示[i,j]位置着火时间 int fireTime[MAXN][MAXN]; // 记录格子有没有走过 int visited[MAXN][MAXN]; queue> q; int dir[4][2] = { {0,1}, {0,-1}, {1,0}, {-1,0}}; // bfs模拟火的蔓延，求取每个格子着火时间 void bfs1() { memset(fireTime, -1, sizeof(fireTime)); while(!q.empty()) q.pop(); for(int i=0; i tmp = q.front(); q.pop(); int x = tmp.first; int y = tmp.second; for(int i=0; i=N || ty>=M) continue; if(fireTime[tx][ty] != -1) continue; if(maze[tx][ty] == '#') continue; fireTime[tx][ty] = fireTime[x][y] + 1; q.push(make_pair(tx,ty)); } } } // bfs求逃离迷宫时间 int bfs2() { memset(visited, -1, sizeof(visited)); while(!q.empty()) q.pop(); for(int i=0; i tmp = q.front(); q.pop(); int x = tmp.first; int y = tmp.second; if(x==0 || y==0 || x==N-1 || y==M-1) return visited[x][y] + 1; for(int i=0; i=N || ty>=M) continue; if(visited[tx][ty] != -1) continue; if(maze[tx][ty]=='#') continue; if(fireTime[tx][ty] != -1 && visited[x][y]+1 >= fireTime[tx][ty]) continue; visited[tx][ty] = visited[x][y] + 1; q.push(make_pair(tx, ty)); } } return -1; } int main(void) { int t; scanf(\"%d\", &t); while(t--) { scanf(\"%d%d\", &N, &M); for(int i=0; i Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-11-07 15:58:11 "}}