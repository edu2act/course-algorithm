{"./":{"url":"./","title":"介绍","keywords":"","body":"算法分析与设计 章节 章节 名称 第一章 概述 第二章 排序 第三章 枚举 第四章 递归 Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-22 18:08:18 "},"slides/ch01.html":{"url":"slides/ch01.html","title":"第一章：概述","keywords":"","body":"第1章 概述 1.1 引言 算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。 一个算法的评价主要从时间复杂度和空间复杂度来考虑。 一个算法应该具有以下五个重要的特征： 有穷性 --- 执行有限条指令后一定要终止。 确定性(无二义) --- 算法的每一步操作都必须有确切定义，不得有任何歧义性。 可(能)行性 --- 算法的每一步操作都必须是可行的，即每步操作均能在有限时间内完成。 输入 --- 一个算法有n(n>=0)个初始数据的输入。 输出 --- 一个算法有一个或多个与输入有某种关系的有效信息的输出。 1.2 时间复杂度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 我们把问题的规模称之为 n ，例如排序问题中 n 为排序元素个数、图的问题中 n 是图的顶点数、矩阵中的 n 为矩阵的阶数等，当 n 不断变化时，花费时间也会不断变化，当我们想知道它变化时呈现什么规律时，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数f(n)，算法的时间度量记作 \r T(n) = O(f(n))\r 表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。 1.3 时间复杂度推导原则 如果运行时间是常数量级，用常数1表示； 只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数。 1.4 例题 问题：一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下。 算法2：对于数组B中的每一个数，都在A中通过二分的方式找一下。 算法3：先把数组B排序，然后用类似外排的方式打印所有不在A中出现的数。 时间复杂度： 算法1时间复杂度：O(M*N) 算法2时间复杂度：O(M*\\log_2^N) 算法3时间复杂度：O(M*\\log_2^M + M + N) 对数组A中M个数排序时间复杂度：O(M*\\log_2^M) 类似于外排方式打印不在数组A中的数时间复杂度：O(M+N) 例如：A[1, 3, 4, 5, 6]、B[8, 2, 5, 3]，B排序后变为[2, 3, 5, 8]。 i ↓ A: 1 3 4 5 6 B: 2 3 5 8 ↑ j for(i=0,j=0; i=A.length) 打印B[j]后面所有元素; Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-19 17:39:21 "},"slides/ch02.html":{"url":"slides/ch02.html","title":"第二章：排序","keywords":"","body":"第2章 排序 2.1 冒泡排序 重复地走访过要排序的元素，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。 冒泡排序是一种稳定排序算法。 时间复杂度 O(N^2) 冒泡排序示例 [2 4 3 1 6 5] 【初始状态】 ------------------------------------------------ [2 4 3 1 6 5] 【第一次冒泡开始】 \\__/ [2 4 3 1 6 5] \\__/ [2 3 4 1 6 5] \\__/ [2 3 1 4 6 5] \\__/ [2 3 1 4 6 5] \\__/ [2 3 1 4 5] [6] 【第一次冒泡结束】 ------------------------------------------------ [2 1 3 4] [5 6] 【第二次冒泡】 [1 2 3] [4 5 6] 【第三次冒泡】 [1 2] [3 4 5 6] 【第四次冒泡】 [1 2 3 4 5 6] 【第五次冒泡】 冒泡排序示例代码 void bubble_sort(int arr[], int len) { for (int i=0; i arr[j+1]) { swap(&arr[j], &arr[j]); } } } } 2.2 选择排序 从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。 时间复杂度 O(N^2) 选择排序示例 [2 4 3 1 6 5] 【初始状态】 ------------------------------------------------ i min j ↓ ↓ ↓ [2 4 3 1 6 5] 【第一次选择开始】 i min j ↓ ↓ ↓ [2 4 3 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min ↓ ↓ [2 3 4 1 6 5] \\__________/ [1] [3 4 2 6 5] 【第一次选择结束】 ------------------------------------------------ [1 2] [4 3 6 5] 【第二次选择】 [1 2 3] [4 6 5] 【第三次选择】 [1 2 3 4] [6 5] 【第四次选择】 [1 2 3 4 5 6] 【第五次选择】 选择排序示例代码 void select_sort(int A[], int n) { int min; for(int i=0; i A[j]) { min = j; } } // 将最小值与到本次循环的首元素交换 swap(&A[min], &A[i]); } } 2.3 插入排序 插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，直到全部插入完为止。插入排序算法适用于少量数据的排序。 插入排序是一种稳定排序算法。 时间复杂度 O(N^2) 插入排序示例 [2 4 3 1 6 5] 【初始状态】 [2] [4 3 1 6 5] │ │ ↓ [2 4] [3 1 6 5] 【第一次插入】 │ ┌───┘ ↓ [2 3 4] [1 6 5] 【第二次插入】 │ ┌───────────┘ ↓ [1 2 3 4] [6 5] 【第三次插入】 │ | ↓ [1 2 3 4 6] [5] 【第四次插入】 │ ┌───┘ ↓ [1 2 3 4 5 6] 【第五次插入】 插入排序示例代码 void insert_sort(int arr[], int n) { int j, temp; for(int i=1; i0 && arr[j-1]>temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } 2.4 希尔排序 希尔排序是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 希尔排序是不稳定的排序方法。 时间复杂度 O(N^{1.3}) 希尔排序示例 0 1 2 3 4 5 6 7 [5 7 8 3 1 2 4 6] 【初始状态】 ------------------------------------------------------------ [5 7 8 3 1 2 4 6] 【第一次分组 增量为4】 │ │ │ │ │ │ │ │ [5] │ │ │ [1] │ │ │ 第1组 [7] │ │ [2] │ │ 第2组 [8] │ [4] │ 第3组 [3] [6] 第4组 [1 2 4 3 5 7 8 6] 【第一次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] │ │ │ [5] │ │ │ 第1组 [2] │ │ [7] │ │ 第2组 [4] │ [8] │ 第3组 [3] [6] 第4组 ------------------------------------------------------------ [1 2 4 3 5 7 8 6] 【第二次分组 增量为2】 │ │ │ │ │ │ │ │ [1] │ [4] │ [5] | [8] │ 第1组 [2] [3] [7] [6] 第2组 [1 2 4 3 5 6 8 7] 【第二次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] │ [4] │ [5] | [8] │ 第1组 [2] [3] [6] [7] 第2组 ------------------------------------------------------------ [1 2 4 3 5 6 8 7] 【第三次分组 增量为1】 │ │ │ │ │ │ │ │ [1] [2] [4] [3] [5] [6] [8] [7] 第1组 [1 2 3 4 5 6 7 8] 【第三次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] [2] [3] [4] [5] [6] [7] [8] 第1组 希尔排序示例代码 void shell_sort(int arr[], int n) { int i,j; for(int d=n/2; d>0; d/=2) { for(i=d; i=0 && temp 2.5 归并排序 归并排序是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序是一种稳定排序算法。 时间复杂度 O(N*log^N) 归并排序示例 [8 4 5 7 1 3 6 2] 【初始状态】 / \\ [8 4 5 7] [1 3 6 2] 分 / \\ / \\ 解 [8 4] [5 7] [1 3] [6 2] / \\ / \\ / \\ / \\ [8] [4] [5] [7] [1] [3] [6] [2] ------ \\ / \\ / \\ / \\ / [4 8] [5 7] [1 3] [2 6] \\ / \\ / 合 [4 5 7 8] [1 2 3 6] 并 \\ / [1 2 3 4 5 6 7 8] 归并排序示例代码 void merge(int arr[],int temp[], int start, int mid, int end) { int i=start, j=mid+1, k=start; while(i!=mid+1 && j!=end+1) { if(arr[i] > arr[j]) temp[k++] = arr[j++]; else temp[k++] = arr[i++]; } while(i != mid+1) temp[k++] = arr[i++]; while(j != end+1) temp[k++] = arr[j++]; for(i=start; i= end) return; int mid = start + (end-start) / 2; // 避免溢出 merge_sort(arr, temp, start, mid); merge_sort(arr, temp, mid+1, end); merge(arr, temp, start, mid, end); } void merge_sort(int arr[], int len) { int * temp = (int *)malloc(sizeof(int) * len); merge_sort(arr, temp, 0, len-1); free(temp); } 2.5.1 递归的时间复杂度 master公式 \r T(N) = a * T(\\frac{N}{b}) + O(N^d)\r N ： 数据样本量 a ： 子过程调用次数 \\frac{N}{b} ： 子过程数据样本量 O(N^d) ： 除去递归之外的时间复杂度 \r 递归时间复杂度 = \r \\begin{cases} \r \tO(N^{log_b^a}) , &log_b^a>d \\\\\r \tO(N^{d}*{log^N}) , &log_b^a=d \\\\\r \tO(N^d) , &log_b^a 2.5.2 数组小和问题 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。 例：[2, 3, 4, 1, 5] 小和为17。 2左边比其小的数： 3左边比其小的数：2 4左边比其小的数：2、 3 1左边比其小的数： 5左边比其小的数：2、 3、 4、 1 思路：求数组中每个数左侧比其小的所有数的和，等同于求每个数右侧比其大的数的数量乘以这个数的和进行累加。 2.5.3 逆序对问题 在一个数组中，左边的数如果比右边的数大，则两个数构成一个逆序对，请输出逆序对数量。 例：[2, 3, 4, 1, 5] 逆序对数量为3，逆序对分别为(2,1)、(3,1)、(4,1)。 2.5.4 瑞士轮问题 在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。 本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折衷，既保证了比赛的稳定性，又能使赛程不至于过长。 2*N 名编号为 1~2N 的选手共进行 R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会对选手进行一次排名。排名的依据是选手的总分。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第2K – 1名和第2K名、…… 、第2N – 1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在 R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 例：根据下表3名选手实力值及初始分数，求取4轮对阵后排名第2的选手为：编号1选手 选手编号 [1] [2] [3] [4] 选手实力值 10 5 20 15 选手初始分(排名) 7(1) 6(3) 6(4) 7(2) 对阵情况 第1轮对阵后 7(2) 6(4) 7(3) 8(1) [1]-[4]     [2]-[3] 第2轮对阵后 7(3) 6(4) 8(2) 9(1) [4]-[1]     [3]-[2] 第3轮对阵后 8(3) 6(4) 9(1) 9(2) [4]-[3]     [1]-[2] 第4轮对阵后 9(2) 6(4) 10(1) 9(3) [3]-[4]     [1]-[2] 思路：首先根据初始分数排序，然后在每次对阵结束后分为胜者组和败者组，分组时保证先进行对阵的选手在前，后对阵的选手在后，这样既保证了胜者组和败者组两组先天有序，再进行归并排序的merge操作，准备下次对阵。时间复杂度：O(N*log^N +R*N) 2.6 快速排序 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序是不稳定的排序方法。 时间复杂度 O(N*log^N) 第一趟快速排序示例 i ←-- j ↓ ↓ [30 24 5 58 18 36 12 42 39] 【快速排序初始化】 ----------------------------------------------------------------- i j ↓ ↓ [30 24 5 58 18 36 12 42 39] 【交换元素】 \\___________________________/ ----------------------------------------------------------------- i --→ j ↓ ↓ [12 24 5 58 18 36 30 42 39] 【交换元素后】 ----------------------------------------------------------------- i j ↓ ↓ [12 24 5 58 18 36 30 42 39] 【交换元素】 \\_____________/ ----------------------------------------------------------------- i ←-- j ↓ ↓ [12 24 5 30 18 36 58 42 39] 【交换元素后】 ----------------------------------------------------------------- i j ↓ ↓ [12 24 5 30 18 36 58 42 39] 【交换元素】 \\___/ ----------------------------------------------------------------- ij ↓↓ [12 24 5 18 30 36 58 42 39] 【交换元素后】 ----------------------------------------------------------------- [12 24 5 18] 30 [36 58 42 39] 【第一趟快速排序结束】 快速排序示例代码 int partition(int arr[], int low, int high) { int i=low, j=high, pivot=arr[low]; while(ipivot) // 从右向左扫描 j--; if(i 2.6.1 分类问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。 思路：指针p从-1位置开始，规划p左侧为小于num的数的区域，然后准备一个指针q指向下标0位置，如果q指向元素小于等于num，则q指向元素与p+1指向元素交换，p、q往后移动；如果q指向元素大于num，则q往后移动，直到q移出数组 2.6.2 荷兰国旗问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。 2.7 堆排序 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆排序是不稳定的排序方法。 时间复杂度 O(N*log^N) 堆排序示例代码 void max_heapify(int arr[], int start, int end) { // 父节点下标和子节点下标 int dad = start, son = dad * 2 + 1; while (son arr[son]) // 父节点大于子节点跳出函数 return; else { // 否则交换父子节点，并继续子节点和孙节点比较 swap(&arr[dad], &arr[son]); dad = son; son = dad * 2 + 1; } } } void heap_sort(int arr[], int len) { // 最后一个非叶子节点为(len-2)/2 for (int i=len/2-1; i>=0; i--) max_heapify(arr, i, len - 1); // 先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕 for (int i=len-1; i>0; i--) { swap(&arr[0], &arr[i]); max_heapify(arr, 0, i - 1); } } 2.7.1 建堆方法：HeapInsert 假定事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。大致步骤如下： 首先增加堆的长度，在最末尾的地方加入最新插入的元素。 比较当前元素和它的父结点值，如果比父结点值大，则交换两个元素，否则返回。 重复步骤2。 这种插入建堆的时间复杂度是 O(N*log^N) HeapInsert 建堆示例 2.7.2 建堆方法：Heapify 从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换，并持续往下递归调整。Heapify是一种类似下沉的操作，HeapInsert是一种类似上浮的操作。 这种建堆的时间复杂度是 O(N) 怎么找到第一个非叶子节点? 如果根节点在数组中的索引为0，那么第一个非叶子节点的计算公式为: last\\_non\\_leav = (arr.length - 2)/2 可以设最后一个非叶子节点位置为x，那么最后一个叶子节点一定是(2x+1) 或者(2x+2)中的一个，然后可以建立方程求解。 Heapify 建堆示例 2.7.3 堆排序示例 将堆顶节点与末尾节点进行交换，使末尾节点最大。然后继续调整堆，再将堆顶节点与末尾节点交换，得到第二大节点。如此反复进行交换、重建、交换。 2.8 桶排序 桶排序或所谓的箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 桶排序是一种稳定排序算法。 平均时间复杂度 O(N+C)，其中 C=N*(logN-logM)，N 为待排数据，M为桶数量。当N=M时，最好效率达到 O(N)。 桶排序示例 桶排序示例代码 #include #include #include using namespace std; // 桶的数量 const int BUCKET_NUM = 10; void bucket_sort(int arr[], int len) { vector buckets[BUCKET_NUM]; // 求取最大值及最小值，确定桶区间范围 int max=arr[0], min=arr[0]; for (int i=1; i arr[i]) min = arr[i]; } // 将数据放入不同的桶中 for (int i=0; i newArr; for (int i=0; i 2.8.1 相邻元素最大差值 给定一个数组，求如果排序之后，相邻两数的最大差值。 思路：根据数组元素数值范围，准备N+1个桶，然后根据桶排序思想将所有元素放入桶中，则必然会存在有一个空桶，便可以排除排序后相邻元素出现在一个桶中的可能性，然后遍历每个桶，求相邻桶（跳过空桶）极值元素最大差值即可，时间复杂度O(N)。 2.9 计数排序 计数排序是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。 计数排序是一种稳定排序算法。 算法过程： 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间； 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内； 对额外空间内数据进行计算，得出每一个元素的正确位置； 将待排序集合每一个元素移动到计算得出的正确位置上。 时间复杂度 O(N+K) （K为数值范围） 计数排序示例代码 void count_sort(int arr[], int len) { if(lenarr[i]) min = arr[i]; } // 临时数组 int * newArr = (int *)malloc(sizeof(int)*len); int n = max-min+1; // 辅助数组 int * p = (int *)malloc(sizeof(int)*n); memset(p, 0, sizeof(int)*n); // 统计各元素出现次数 for(int i=0; i=0; i--) { newArr[p[arr[i]-min]-1]=arr[i]; p[arr[i]-min]--; } // 将排序好的元素拷贝回arr memcpy(arr, newArr, sizeof(int)*len); free(newArr); free(p); } 2.10 基数排序 基数排序属于“分配式排序”，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。 基数排序是一种稳定排序算法。 时间复杂度 O(D*N) （D为基数位数） 基数排序示例代码 // 辅助函数，求数据的最大位数 int max_bit(int data[], int n) { int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i = p) { p *= 10; ++d; } } return d; } void radix_sort(int arr[], int len) { int bit = max_bit(arr, len); int * tmpArr = (int *)malloc(sizeof(int)*len); int * countArr = (int *)malloc(sizeof(int)*10); int radix = 1; for(int i=1; i=0; --j) { int k = (arr[j]/radix)%10; tmpArr[countArr[k]-1] = arr[j]; countArr[k]--; } // 将临时数组的内容复制到原数组中 for(int j=0; j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-19 17:39:21 "},"slides/ch03.html":{"url":"slides/ch03.html","title":"第三章：枚举","keywords":"","body":"第3章 枚举 把问题所有可能的解一一进行检验，排除后得到正确可行解的过程称为枚举，这种方法是牺牲时间和空间来换取较高的准确性，所以当可能的解范围较大时，一般不建议使用这种方法。 枚举的时间复杂度一般为所有可能解的范围，但在绝大多数情况下，可以进行优化处理，缩小可能解的范围，或者根据问题的相关性质有选择性的跳跃搜索正解。 枚举简单粗暴，当可能的解范围确定时，暴力枚举所有可能的解，使用枚举算法时，要保证可能的解范围确定，并且一定能在这个范围内找到正解，其本质上就是搜索。 3.1 水仙花数 [题面] 水仙花数是指一个 n 位数（n \\geq 3），它每个位上的数字的 n 次幂之和等于它本身（如 1^3+5^3+3^3=153 ），求出所有三位数的水仙花数。 [输入] 无输入。 [输出] 从小到大顺序输出所有水仙花数，每行输出一个水仙花数。 [思路1] 直接遍历100~999，判断每个数是否满足是水仙花数的条件。判断的时候把每个数拆分出个位、十位、百位，然后判断是否满足。 [思路2] 利用三重循环，分别模拟个位、十位、百位，然后输出满足条件的数。 3.2 百钱买百鸡 [题面] 元前五世纪，我国古代数学家张丘建在《算经》一书中提出了“百鸡问题”：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 本程序要求解的问题是：给定一个正整数n，用n文钱买n只鸡，问公鸡、母鸡、小鸡各买多少只？ [输入] 输入一个正整数 n(n。 [输出] 如果有解，每种组合占一行，包含公鸡、母鸡、小鸡的个数，用正整数表示，每个数据占4列。公鸡母鸡小鸡个数均大于等于0，按公鸡数目从小到大输出，公鸡数目相同按母鸡数目从小到大输出，以此类推。如果无解，输出“No Answer”。 [样例输入] 100 [样例输出] 0 25 75 4 18 78 8 11 81 12 4 84 [思路1] 根据题意，假设 x 只公鸡， y 只母鸡， z 只小鸡，可以得到方程组 \r \\begin{cases} \r \t5x+3y+z/3 = n \\\\\r \tx+y+z = n\r \\end{cases}\r 其中， 0 \\leq x,y,z \\leq n \\ \\ \\& \\& \\ \\ z \\% 3 == 0 ，然后可以对其进行一一枚举。 [思路2] 通过已知条件对方法1进行优化，减少枚举次数。3种鸡的总数是固定的，只需要枚举公鸡和母鸡，即可确定小鸡的数量 z == n-x-y ，这样就缩小了枚举范围，去掉一个未知数，得到 \r \\begin{cases}\r \t7x+4y=n \\\\\r \tx+y+z=n\r \\end{cases}\r 其中， 0 \\leq x,y,z \\leq n \\ \\ \\& \\ \\ z \\% 3 == 0 中的 x 值可以缩小范围为 0 \\leq x \\leq \\frac{n}{4} 。 [参考代码] #include int main(void) { int n, x, y, z; scanf(\"%d\", &n); for(x=0; x=0) { y /= 4; z = 100-x-y; if(z%3==0 && 5*x+3*y+z/3==n) printf(\"%d %d %d\\n\", x, y, z); } } return 0; } 3.3 完美立方 [题面] 形如 a^3 = b^3 + c^3 + d^3 的等式被称为完美立方等式。例如 12^3 = 6^3 + 8^3 + 10^3 。编写一个程序，对任给的正整数 N(N \\leq 100) ，寻找所有的四元组 (a, b, c, d) ，使得 a^3= b^3 + c^3 + d^3 ，其中a,b,c,d 大于 1, 小于等于N，且 b \\leq c \\leq d。 [输入] 一个正整数 N (N \\leq 100)。 [题面] 每行输出一个完美立方。 输出格式为： Cube = a, Triple = (b,c,d) 其中a，b，c，d所在位置分别用实际求出四元组值代入。 请按照a的值，从小到大依次输出。当两个完美立方等式中a的值相同，则b值小的优先输出，仍相同则c值小的优先输出，再相同则d值小的先输出。 [样例输入] 24 [样例输出] Cube = 6, Triple = (3,4,5) Cube = 12, Triple = (6,8,10) Cube = 18, Triple = (2,12,16) Cube = 18, Triple = (9,12,15) Cube = 19, Triple = (3,10,18) Cube = 20, Triple = (7,14,17) Cube = 24, Triple = (12,16,20) [思路] 使用四重循环枚举a、b、c、d，a在最外层，d在最里层，每一层都是从小到大枚举。 a的枚举范围：[ 2, N ] b的枚举范围：[ 2, a-1 ] c的枚举范围：[ b, a-1 ] d的枚举范围：[ c, a-1 ]​ [参考代码] #include int main(void) { int n; scanf(\"%d\", &n); for(int a=2; a 3.4 生理周期 [题面] 人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为23天、28天和33天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为10，下次出现三个高峰同天的时间是12，则输出2（注意这里不是3）。 [输入] 多组数据。一行包含四个整数：p, e, i和d，相邻两个整数之间用单个空格隔开。 p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于p, e, 或 i。 所有给定时间是非负的并且小于等于365, 所求的时间小于等于21252。 [输出] 对每组数据输出一行，每行一个整数，即从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。 [样例输入] 0 0 0 0 0 0 0 100 5 20 34 325 4 5 6 7 283 102 23 320 203 301 203 40 [样例输出] 21252 21152 19575 16994 8910 10789 [思路] 从d+1天开始，一直试到第21252天，对其中每个日期k，看是否满足如下条件。 (k-p) \\% 23 == 0 \\ \\ \\&\\&\\ \\ (k-e) \\% 28 == 0 \\ \\ \\&\\& \\ \\ (k-i) \\% 33 == 0 根据题意，对算法进行优化即可。 [参考代码] #include int main(void) { int p, e, i, d; while(~scanf(\"%d %d %d %d\", &p, &e, &i, &d)) { int k; for(k=d+1; (k-p)%23; ++k); for(; (k-e)%28; k+=23); for(; (k-i)%33; k+=23*28); printf(\"%d\\n\", k-d); } return 0; } 3.5 假币问题 赛利有12枚银币。其中有11枚真币和1枚假币。假币看起来和真币没有区别，但是重量不同。但赛利不知道假币比真币轻还是重。于是他向朋友借了一架天平。朋友希望赛利称三次就能找出假币并且确定假币是轻是重。例如：如果赛利用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果赛利用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。经过精心安排每次的称量，赛利保证在称三次后确定假币。 [输入] 第一行有一个数字n，表示有n组测试用例。 对于每组测试用例： 输入有三行，每行表示一次称量的结果。赛利事先将银币标号为A-L。每次称量的结果用三个以空格隔开的字符串表示：天平左边放置的硬币 天平右边放置的硬币 平衡状态。其中平衡状态用\"up\"，\"down\"， 或 \"even\"表示，分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。 [输出] 输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)。 [样例输入] 1 ABCD EFGH even ABCI EFJK up ABIJ EFGH even [样例输出] K is the counterfeit coin and it is light. [思路] 对每一枚硬币先假设它是轻的，看这样是否符合称重的结果，如果符合，问题即解决。如果不符合，就假设它是重的，看是否符合称重的结果。把所有的硬币都试一遍，一定能找到特殊的硬币。 [参考代码] #include #include char left[3][13]; // 天平左边的硬币 char right[3][13]; // 天平右边的硬币 char result[3][6]; // 结果 // light为1表示假设假币为轻，0表示为重 int isFake(char c, int light) { for(int i=0; i 3.6 猜数字 [题面] 猜数字游戏是gameboy最喜欢的游戏之一。游戏的规则是这样的：计算机随机产生一个四位数，然后玩家猜这个四位数是什么。每猜一个数，计算机都会告诉玩家猜对几个数字，其中有几个数字在正确的位置上。 比如计算机随机产生的数字为1122。如果玩家猜1234,因为1,2这两个数字同时存在于这两个数中，而且1在这两个数中的位置是相同的，所以计算机会告诉玩家猜对了2个数字，其中一个在正确的位置。如果玩家猜1111,那么计算机会告诉他猜对2个数字，有2个在正确的位置。 现在给你一段gameboy与计算机的对话过程，你的任务是根据这段对话确定这个四位数是什么。 [输入] 输入数据有多组。每组的第一行为一个正整数N(1 \\leq N \\leq 100)，表示在这段对话中共有N次问答。在接下来的N行中，每行三个整数A,B,C。gameboy猜这个四位数为A，然后计算机回答猜对了B个数字，其中C个在正确的位置上。当N=0时，输入数据结束。 [输出] 每组输入数据对应一行输出。如果根据这段对话能确定这个四位数，则输出这个四位数，若不能，则输出“Not sure”。 [样例输入] 6 4815 2 1 5716 1 0 7842 1 0 4901 0 0 8585 3 3 8555 3 2 2 4815 0 0 2999 3 3 0 [样例输出] 3585 Not sure [思路] 因为随机产生的数一定是四位数，所以求解范围不大，可以使用枚举的方法。对于每一个四位数，判断其是否与输入中的对话冲突，但是在找到一个符合条件的数时，仍要继续枚举，指导出现第二个符合条件的数或者枚举完所有的四位数时，枚举结束。当有两个符合条件的数或者枚举结束都没找到一个符合条件的数时，输出“Not sure”，当且仅有一个符合条件数时，输出这个数。 [参考代码] #include #include const int N = 110; struct Arr{ int a,b,c; } arr[N]; int hashA[10], hashB[10]; int judge(int y, int n) { memset(hashA, 0, sizeof(hashA)); int A1, B1, C1, D1, A2, B2, C2, D2; A1 = y%10; hashA[A1]++; B1 = y/10%10; hashA[B1]++; C1 = y/100%10; hashA[C1]++; D1 = y/1000; hashA[D1]++; for(int i=0; i 3.7 熄灯问题 [题面] 有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。 在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。 请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。 [输入] 5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。 [输出] 5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。 [样例输入] 0 1 1 0 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 1 0 1 0 1 1 1 0 0 [样例输出] 1 0 1 0 0 1 1 1 0 1 0 1 0 0 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 [思路] 按下按钮顺序不影响最终结果； 按下一个按钮两次等价于没有按这个按钮，故每个按钮最多只需按一次。 一共30个开关，那么状态数是2^30，需要减少枚举的状态数目。 基本思路：如果存在某个局部，一旦这个局部状态被确定，那么剩余其它部分的状态只能是确定的一种，或者不多的n种，那么就只需枚举这个局部的状态即可。 经过观察，发现第1行就是这样一个“局部”。 因为第1行的各开关状态确定的状态下，这些开关作用过后，将导致第1行某些灯是亮的，某些灯是灭的。 要熄灭第1行某个亮着的灯（假设位于第i列），那么唯一的方法就是第2行第i列的按钮。（因为第1行的开关已经用过了，而第3行及其后面的开关不会影响到第1行） 为了使第1行的灯全部熄灭，第2行的合理开关状态就是唯一的。 枚举第1行状态数是2^6，同理枚举第1列状态数是2^5。 因为按钮状态只有开关两种，所以在是现实时可以通过位运算来实现。 [参考代码] #include #include int get_bit(char c, int i) { return (c >> i) & 1; } void set_bit(char &c, int i, int v) { if(v) c |= (1 0) flip_bit(lights[i], j-1); // 更改开关位置灯状态 flip_bit(lights[i], j); // 更改右等状态 if(j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-23 08:53:43 "},"slides/ch04.html":{"url":"slides/ch04.html","title":"第四章：递归","keywords":"","body":"第4章 递归 一个函数直接或者间接调用自己本身，这种函数称为递归函数，而递归算法是把问题转化为规模缩小了的同类问题的子问题，然后调用递归函数表示问题的解，其思想是将一个大型而且复杂的问题层层简化，转化为一个与原问题相似的规模较小且简单的子问题，通过多次调用子问题得到最终复杂问题的解。 在递归调用的过程中，系统为每一层的返回点、局部变量等开辟了栈来存储，为了避免栈溢出的问题，递归需要有边界条件，必须有一个明确的递归出口。 4.1 母牛的故事 [题面] 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第 n 年的时候，共有多少头母牛？ [输入] 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数 n(0，n 的含义如题目中描述。 n=0 表示输入数据的结束，不做处理。 [输出] 对于每个测试实例，输出在第 n 年的时候母牛的数量。 每个输出占一行。 [样例输入] 2 4 5 0 [样例输出] 2 4 6 [思路] 假设第 n 年母牛数为 cow[n]，根据题意可以知道 cow[1] =1， cow[2] = 2， cow[3] = 3；当 n>3 时，就要推公式再进行递归求解。第 n 年的母牛数可以分为两部分；第一部分为第 n-1 年的母牛总数；第二部分为第 n 年年初刚生育的小牛数，而第 n 年年初刚生育的小牛数等于第 n-3 年的母牛总数。所以，当 n>3 时，cow[n] = cow[n-1] + cow[n-3]。 为了减少不必要的重复递归，可以使用数组 cow[i] 进行记忆化递归。 [参考代码] #include int cow[60] = {0}; int cowNumber(int n) { if(cow[n]) return cow[n]; if(n 4.2 汉诺塔问题 [题面] 法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。 不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有 n 片，移动次数是f(n)。 显然 f(1)=1,f(2)=3,f(3)=7，且 f(k+1)=2*f(k)+1。此后不难证明 f(n)=2^n-1。n=64时， 假如每秒钟一次，共需多长时间呢？一个平年365天有31536000秒，闰年366天有31622400秒，平均每年31556952秒，计算一下： 18,446,744,073,709,551,615秒 这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 [输入] 输入为一个整数后面跟三个单字符字符串。 整数为盘子的数目，后三个字符表示三个杆子的编号。 [输出] 输出每一步移动盘子的记录。一次移动一行。 每次移动的记录为例如3:a->b 的形式，即把编号为3的盘子从a杆移至b杆。 我们约定圆盘从小到大编号为 1, 2, ...n。即最上面那个最小的圆盘编号为1，最下面最大的圆盘编号为 n。 [样例输入] 3 a b c [样例输出] 1:a->c 2:a->b 1:c->b 3:a->c 1:b->a 2:b->c 1:a->c [思路] 解法的基本思想是递归。假设有A、B、C三个塔，A塔有N块盘，目标是把这些盘全部移到C塔。那么先把A塔顶部的N-1块盘移动到B塔，再把A塔剩下的大盘移到C，最后把B塔的N-1块盘移到C。 每次移动多于一块盘时，则再次使用上述算法来移动。 [参考代码] #include // 将src座上的n个盘子以mid座为中转移动到dest座， // src座上最上方盘子编号是src_n void hanoi(int n, char src, char mid, char dest, int src_n) { if(n == 1) { // 只需移动一个盘子，直接将盘子从src移动到dest即可 printf(\"%d:%c->%c\\n\", src_n, src, dest); return; } // 先将n-1个盘子从src移动到mid hanoi(n-1, src, dest, mid, src_n); // 再将第n个盘子从src移动到dest printf(\"%d:%c->%c\\n\", src_n+n-1, src, dest); // 最后将n-1个盘子从mid移动到dest hanoi(n-1, mid, src, dest, src_n); return ; } int main(void) { char a, b, c; int n; scanf(\"%d %c %c %c\", &n, &a, &b, &c); hanoi(n, a, b, c, 1); return 0; } 4.3 N皇后问题 [题面] 在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。 你的任务是，对于给定的N，求出有多少种合法的放置方法。 [输出] 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 [输出] 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 [样例输入] 1 8 5 0 [样例输出] 1 92 10 [思路] [参考代码] #include using namespace std; const int N = 10; int cnt; int arr[N];//arr[i]=j，表示皇后在第i行第j列 void Queens(int i,int n) { if(i==n) { ++cnt; return ; } else for(int j = 0; j>n,n) { cout 4.4 阿牛的EOF牛肉串 [题面] 今年的ACM暑期集训队一共有18人，分为6支队伍。其中有一个叫做EOF的队伍，由04级的阿牛、XC以及05级的COY组成。在共同的集训生活中，大家建立了深厚的友谊，阿牛准备做点什么来纪念这段激情燃烧的岁月，想了一想，阿牛从家里拿来了一块上等的牛肉干，准备在上面刻下一个长度为n的只由\"E\" \"O\" \"F\"三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）,阿牛同时禁止在串中出现O相邻的情况，他认为，\"OO\"看起来就像发怒的眼睛，效果不好。 你能帮阿牛算一下一共有多少种满足要求的不同的字符串吗？ [输入] 输入数据包含多个测试实例,每个测试实例占一行，由一个整数 n 组成，(0。 [输出] 对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。 [样例输入] 1 2 [样例输出] 3 8 [思路] 因为两个 O 不能连在一起，所以考虑两种单独的情况。设长度为 n 时的 x[n]=a[n]+b[n]，其中，a[n] 代表长度为 n 时末尾为 O 的情况总和， b[n] 代表长度为 n 时末尾不为 O 的情况总和。 那么分情况讨论： 当长度为 n，末尾为 O 时，再加一个单位的长度有两种加法，即 E，F。 当长度为 n，末尾不为 O 时，再加一个单位的长度有三种加法，即 E，O，F。 所以 x[n+1] = a[n+1] + b[n+1] = 2*a[n] + 3*b[n] = 2*x[n] + b[n] 。 而 b[n] 又由 x[n+1] 推来，x[n-1] = a[n-1] + b[n-1]，在长度为 n-1 且末尾为 O 时，要将它变成长度为 n 且末尾不为 O 有两种方法（E，F），即 2*a[n-1]。 同理，在长度为 n-1 且末尾不为 O 时，要将它变成长度为 n 且末尾不为 O 有两种方法（E，F），即 2*b[n-1]。 所以 x[n+1] = 2*x[n] + b[n] = 2*x[n] + 2*x[n-1]。 [参考代码] #include int main(void) { long long arr[50] = {0}; arr[1] = 3; arr[2] = 8; for(int i=3; i 4.5 RPG难题 [题面] 著名的RPG难题: 有排成一行的 ｎ 个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色。求全部的满足要求的涂法。 [输入] 输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0 [输出] 对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。 [样例输入] 1 2 [样例输出] 3 6 [思路] 当长度为 n 时，满足要求的涂法为 x[n]，设3中颜色为A、B、C，由 x[n] 推出 x[n+1]。 若长度为 n 时，序列为 ABC···BAC，那么在后面加一个，只有一种加法，因为既要与开头不一样，又要与末尾不一样，所以只能加 B，因此从 n 变为 n+1 只有一种方法。 然而，还有种情况忽略了，就是当长度为 n-1 时，序列为 ABC···CB 时，若在其后加一个 A 变成 ABC···CBA 是不符合题意的，但可以在后面加两个让其变得有意义，如 ABC···CBAC 或者 ABC···CBAB，可得出从 n-1 变为 n+1 有两种方法。 所以，可以退出公式 x[n] = x[n-1] + 2*x[n-2]。 [参考代码] #include int main(void) { long long arr[60] = {0}; arr[1] = 3; arr[2] = arr[3] = 6; for(int i=4; i Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-22 22:20:35 "}}