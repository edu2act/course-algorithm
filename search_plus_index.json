{"./":{"url":"./","title":"介绍","keywords":"","body":"算法分析与设计 章节 章节 名称 第一章 概述 第二章 排序 第三章 枚举 第四章 递归 第五章 贪心 第六章 深度优先搜索 Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-12 08:51:19 "},"slides/ch01.html":{"url":"slides/ch01.html","title":"第一章：概述","keywords":"","body":"第1章 概述 1.1 引言 算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。 一个算法的评价主要从时间复杂度和空间复杂度来考虑。 一个算法应该具有以下五个重要的特征： 有穷性 --- 执行有限条指令后一定要终止。 确定性(无二义) --- 算法的每一步操作都必须有确切定义，不得有任何歧义性。 可(能)行性 --- 算法的每一步操作都必须是可行的，即每步操作均能在有限时间内完成。 输入 --- 一个算法有n(n>=0)个初始数据的输入。 输出 --- 一个算法有一个或多个与输入有某种关系的有效信息的输出。 1.2 时间复杂度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 我们把问题的规模称之为 n ，例如排序问题中 n 为排序元素个数、图的问题中 n 是图的顶点数、矩阵中的 n 为矩阵的阶数等，当 n 不断变化时，花费时间也会不断变化，当我们想知道它变化时呈现什么规律时，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数f(n)，算法的时间度量记作 \r T(n) = O(f(n))\r 表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。 1.3 时间复杂度推导原则 如果运行时间是常数量级，用常数1表示； 只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数。 1.4 例题 问题：一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下。 算法2：对于数组B中的每一个数，都在A中通过二分的方式找一下。 算法3：先把数组B排序，然后用类似外排的方式打印所有不在A中出现的数。 时间复杂度： 算法1时间复杂度：O(M*N) 算法2时间复杂度：O(M*\\log_2^N) 算法3时间复杂度：O(M*\\log_2^M + M + N) 对数组A中M个数排序时间复杂度：O(M*\\log_2^M) 类似于外排方式打印不在数组A中的数时间复杂度：O(M+N) 例如：A[1, 3, 4, 5, 6]、B[8, 2, 5, 3]，B排序后变为[2, 3, 5, 8]。 i ↓ A: 1 3 4 5 6 B: 2 3 5 8 ↑ j for(i=0,j=0; i=A.length) 打印B[j]后面所有元素; Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-12 08:49:06 "},"slides/ch02.html":{"url":"slides/ch02.html","title":"第二章：排序","keywords":"","body":"第2章 排序 2.1 冒泡排序 重复地走访过要排序的元素，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。 冒泡排序是一种稳定排序算法。 时间复杂度 O(N^2) 冒泡排序示例 [2 4 3 1 6 5] 【初始状态】 ------------------------------------------------ [2 4 3 1 6 5] 【第一次冒泡开始】 \\__/ [2 4 3 1 6 5] \\__/ [2 3 4 1 6 5] \\__/ [2 3 1 4 6 5] \\__/ [2 3 1 4 6 5] \\__/ [2 3 1 4 5] [6] 【第一次冒泡结束】 ------------------------------------------------ [2 1 3 4] [5 6] 【第二次冒泡】 [1 2 3] [4 5 6] 【第三次冒泡】 [1 2] [3 4 5 6] 【第四次冒泡】 [1 2 3 4 5 6] 【第五次冒泡】 冒泡排序示例代码 void bubble_sort(int arr[], int len) { for (int i=0; i arr[j+1]) { swap(&arr[j], &arr[j]); } } } } 2.2 选择排序 从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。 时间复杂度 O(N^2) 选择排序示例 [2 4 3 1 6 5] 【初始状态】 ------------------------------------------------ i min j ↓ ↓ ↓ [2 4 3 1 6 5] 【第一次选择开始】 i min j ↓ ↓ ↓ [2 4 3 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min j ↓ ↓ ↓ [2 3 4 1 6 5] i min ↓ ↓ [2 3 4 1 6 5] \\__________/ [1] [3 4 2 6 5] 【第一次选择结束】 ------------------------------------------------ [1 2] [4 3 6 5] 【第二次选择】 [1 2 3] [4 6 5] 【第三次选择】 [1 2 3 4] [6 5] 【第四次选择】 [1 2 3 4 5 6] 【第五次选择】 选择排序示例代码 void select_sort(int A[], int n) { int min; for(int i=0; i A[j]) { min = j; } } // 将最小值与到本次循环的首元素交换 swap(&A[min], &A[i]); } } 2.3 插入排序 插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，直到全部插入完为止。插入排序算法适用于少量数据的排序。 插入排序是一种稳定排序算法。 时间复杂度 O(N^2) 插入排序示例 [2 4 3 1 6 5] 【初始状态】 [2] [4 3 1 6 5] │ │ ↓ [2 4] [3 1 6 5] 【第一次插入】 │ ┌───┘ ↓ [2 3 4] [1 6 5] 【第二次插入】 │ ┌───────────┘ ↓ [1 2 3 4] [6 5] 【第三次插入】 │ | ↓ [1 2 3 4 6] [5] 【第四次插入】 │ ┌───┘ ↓ [1 2 3 4 5 6] 【第五次插入】 插入排序示例代码 void insert_sort(int arr[], int n) { int j, temp; for(int i=1; i0 && arr[j-1]>temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } 2.4 希尔排序 希尔排序是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 希尔排序是不稳定的排序方法。 时间复杂度 O(N^{1.3}) 希尔排序示例 0 1 2 3 4 5 6 7 [5 7 8 3 1 2 4 6] 【初始状态】 ------------------------------------------------------------ [5 7 8 3 1 2 4 6] 【第一次分组 增量为4】 │ │ │ │ │ │ │ │ [5] │ │ │ [1] │ │ │ 第1组 [7] │ │ [2] │ │ 第2组 [8] │ [4] │ 第3组 [3] [6] 第4组 [1 2 4 3 5 7 8 6] 【第一次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] │ │ │ [5] │ │ │ 第1组 [2] │ │ [7] │ │ 第2组 [4] │ [8] │ 第3组 [3] [6] 第4组 ------------------------------------------------------------ [1 2 4 3 5 7 8 6] 【第二次分组 增量为2】 │ │ │ │ │ │ │ │ [1] │ [4] │ [5] | [8] │ 第1组 [2] [3] [7] [6] 第2组 [1 2 4 3 5 6 8 7] 【第二次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] │ [4] │ [5] | [8] │ 第1组 [2] [3] [6] [7] 第2组 ------------------------------------------------------------ [1 2 4 3 5 6 8 7] 【第三次分组 增量为1】 │ │ │ │ │ │ │ │ [1] [2] [4] [3] [5] [6] [8] [7] 第1组 [1 2 3 4 5 6 7 8] 【第三次分组插入排序完成后】 │ │ │ │ │ │ │ │ [1] [2] [3] [4] [5] [6] [7] [8] 第1组 希尔排序示例代码 void shell_sort(int arr[], int n) { int i,j; for(int d=n/2; d>0; d/=2) { for(i=d; i=0 && temp 2.5 归并排序 归并排序是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序是一种稳定排序算法。 时间复杂度 O(N*log^N) 归并排序示例 [8 4 5 7 1 3 6 2] 【初始状态】 / \\ [8 4 5 7] [1 3 6 2] 分 / \\ / \\ 解 [8 4] [5 7] [1 3] [6 2] / \\ / \\ / \\ / \\ [8] [4] [5] [7] [1] [3] [6] [2] ------ \\ / \\ / \\ / \\ / [4 8] [5 7] [1 3] [2 6] \\ / \\ / 合 [4 5 7 8] [1 2 3 6] 并 \\ / [1 2 3 4 5 6 7 8] 归并排序示例代码 void merge(int arr[],int temp[], int start, int mid, int end) { int i=start, j=mid+1, k=start; while(i!=mid+1 && j!=end+1) { if(arr[i] > arr[j]) temp[k++] = arr[j++]; else temp[k++] = arr[i++]; } while(i != mid+1) temp[k++] = arr[i++]; while(j != end+1) temp[k++] = arr[j++]; for(i=start; i= end) return; int mid = start + (end-start) / 2; // 避免溢出 merge_sort(arr, temp, start, mid); merge_sort(arr, temp, mid+1, end); merge(arr, temp, start, mid, end); } void merge_sort(int arr[], int len) { int * temp = (int *)malloc(sizeof(int) * len); merge_sort(arr, temp, 0, len-1); free(temp); } 2.5.1 递归的时间复杂度 master公式 \r T(N) = a * T(\\frac{N}{b}) + O(N^d)\r N ： 数据样本量 a ： 子过程调用次数 \\frac{N}{b} ： 子过程数据样本量 O(N^d) ： 除去递归之外的时间复杂度 \r 递归时间复杂度 = \r \\begin{cases} \r \tO(N^{log_b^a}) , &log_b^a>d \\\\\r \tO(N^{d}*{log^N}) , &log_b^a=d \\\\\r \tO(N^d) , &log_b^a 2.5.2 数组小和问题 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。 例：[2, 3, 4, 1, 5] 小和为17。 2左边比其小的数： 3左边比其小的数：2 4左边比其小的数：2、 3 1左边比其小的数： 5左边比其小的数：2、 3、 4、 1 思路：求数组中每个数左侧比其小的所有数的和，等同于求每个数右侧比其大的数的数量乘以这个数的和进行累加。 2.5.3 逆序对问题 在一个数组中，左边的数如果比右边的数大，则两个数构成一个逆序对，请输出逆序对数量。 例：[2, 3, 4, 1, 5] 逆序对数量为3，逆序对分别为(2,1)、(3,1)、(4,1)。 2.5.4 瑞士轮问题 在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。 本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折衷，既保证了比赛的稳定性，又能使赛程不至于过长。 2*N 名编号为 1~2N 的选手共进行 R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会对选手进行一次排名。排名的依据是选手的总分。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第2K – 1名和第2K名、…… 、第2N – 1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在 R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 例：根据下表3名选手实力值及初始分数，求取4轮对阵后排名第2的选手为：编号1选手 选手编号 [1] [2] [3] [4] 选手实力值 10 5 20 15 选手初始分(排名) 7(1) 6(3) 6(4) 7(2) 对阵情况 第1轮对阵后 7(2) 6(4) 7(3) 8(1) [1]-[4]     [2]-[3] 第2轮对阵后 7(3) 6(4) 8(2) 9(1) [4]-[1]     [3]-[2] 第3轮对阵后 8(3) 6(4) 9(1) 9(2) [4]-[3]     [1]-[2] 第4轮对阵后 9(2) 6(4) 10(1) 9(3) [3]-[4]     [1]-[2] 思路：首先根据初始分数排序，然后在每次对阵结束后分为胜者组和败者组，分组时保证先进行对阵的选手在前，后对阵的选手在后，这样既保证了胜者组和败者组两组先天有序，再进行归并排序的merge操作，准备下次对阵。时间复杂度：O(N*log^N +R*N) 2.6 快速排序 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序是不稳定的排序方法。 时间复杂度 O(N*log^N) 第一趟快速排序示例 i ←-- j ↓ ↓ [30 24 5 58 18 36 12 42 39] 【快速排序初始化】 ----------------------------------------------------------------- i j ↓ ↓ [30 24 5 58 18 36 12 42 39] 【交换元素】 \\___________________________/ ----------------------------------------------------------------- i --→ j ↓ ↓ [12 24 5 58 18 36 30 42 39] 【交换元素后】 ----------------------------------------------------------------- i j ↓ ↓ [12 24 5 58 18 36 30 42 39] 【交换元素】 \\_____________/ ----------------------------------------------------------------- i ←-- j ↓ ↓ [12 24 5 30 18 36 58 42 39] 【交换元素后】 ----------------------------------------------------------------- i j ↓ ↓ [12 24 5 30 18 36 58 42 39] 【交换元素】 \\___/ ----------------------------------------------------------------- ij ↓↓ [12 24 5 18 30 36 58 42 39] 【交换元素后】 ----------------------------------------------------------------- [12 24 5 18] 30 [36 58 42 39] 【第一趟快速排序结束】 快速排序示例代码 int partition(int arr[], int low, int high) { int i=low, j=high, pivot=arr[low]; while(ipivot) // 从右向左扫描 j--; if(i 2.6.1 分类问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。 思路：指针p从-1位置开始，规划p左侧为小于num的数的区域，然后准备一个指针q指向下标0位置，如果q指向元素小于等于num，则q指向元素与p+1指向元素交换，p、q往后移动；如果q指向元素大于num，则q往后移动，直到q移出数组 2.6.2 荷兰国旗问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。 2.7 堆排序 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆排序是不稳定的排序方法。 时间复杂度 O(N*log^N) 堆排序示例代码 void max_heapify(int arr[], int start, int end) { // 父节点下标和子节点下标 int dad = start, son = dad * 2 + 1; while (son arr[son]) // 父节点大于子节点跳出函数 return; else { // 否则交换父子节点，并继续子节点和孙节点比较 swap(&arr[dad], &arr[son]); dad = son; son = dad * 2 + 1; } } } void heap_sort(int arr[], int len) { // 最后一个非叶子节点为(len-2)/2 for (int i=len/2-1; i>=0; i--) max_heapify(arr, i, len - 1); // 先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕 for (int i=len-1; i>0; i--) { swap(&arr[0], &arr[i]); max_heapify(arr, 0, i - 1); } } 2.7.1 建堆方法：HeapInsert 假定事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。大致步骤如下： 首先增加堆的长度，在最末尾的地方加入最新插入的元素。 比较当前元素和它的父结点值，如果比父结点值大，则交换两个元素，否则返回。 重复步骤2。 这种插入建堆的时间复杂度是 O(N*log^N) HeapInsert 建堆示例 2.7.2 建堆方法：Heapify 从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换，并持续往下递归调整。Heapify是一种类似下沉的操作，HeapInsert是一种类似上浮的操作。 这种建堆的时间复杂度是 O(N) 怎么找到第一个非叶子节点? 如果根节点在数组中的索引为0，那么第一个非叶子节点的计算公式为: last\\_non\\_leav = (arr.length - 2)/2 可以设最后一个非叶子节点位置为x，那么最后一个叶子节点一定是(2x+1) 或者(2x+2)中的一个，然后可以建立方程求解。 Heapify 建堆示例 2.7.3 堆排序示例 将堆顶节点与末尾节点进行交换，使末尾节点最大。然后继续调整堆，再将堆顶节点与末尾节点交换，得到第二大节点。如此反复进行交换、重建、交换。 2.8 桶排序 桶排序或所谓的箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 桶排序是一种稳定排序算法。 平均时间复杂度 O(N+C)，其中 C=N*(logN-logM)，N 为待排数据，M为桶数量。当N=M时，最好效率达到 O(N)。 桶排序示例 桶排序示例代码 #include #include #include using namespace std; // 桶的数量 const int BUCKET_NUM = 10; void bucket_sort(int arr[], int len) { vector buckets[BUCKET_NUM]; // 求取最大值及最小值，确定桶区间范围 int max=arr[0], min=arr[0]; for (int i=1; i arr[i]) min = arr[i]; } // 将数据放入不同的桶中 for (int i=0; i newArr; for (int i=0; i 2.8.1 相邻元素最大差值 给定一个数组，求如果排序之后，相邻两数的最大差值。 思路：根据数组元素数值范围，准备N+1个桶，然后根据桶排序思想将所有元素放入桶中，则必然会存在有一个空桶，便可以排除排序后相邻元素出现在一个桶中的可能性，然后遍历每个桶，求相邻桶（跳过空桶）极值元素最大差值即可，时间复杂度O(N)。 2.9 计数排序 计数排序是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。 计数排序是一种稳定排序算法。 算法过程： 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间； 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内； 对额外空间内数据进行计算，得出每一个元素的正确位置； 将待排序集合每一个元素移动到计算得出的正确位置上。 时间复杂度 O(N+K) （K为数值范围） 计数排序示例代码 void count_sort(int arr[], int len) { if(lenarr[i]) min = arr[i]; } // 临时数组 int * newArr = (int *)malloc(sizeof(int)*len); int n = max-min+1; // 辅助数组 int * p = (int *)malloc(sizeof(int)*n); memset(p, 0, sizeof(int)*n); // 统计各元素出现次数 for(int i=0; i=0; i--) { newArr[p[arr[i]-min]-1]=arr[i]; p[arr[i]-min]--; } // 将排序好的元素拷贝回arr memcpy(arr, newArr, sizeof(int)*len); free(newArr); free(p); } 2.10 基数排序 基数排序属于“分配式排序”，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。 基数排序是一种稳定排序算法。 时间复杂度 O(D*N) （D为基数位数） 基数排序示例代码 // 辅助函数，求数据的最大位数 int max_bit(int data[], int n) { int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i = p) { p *= 10; ++d; } } return d; } void radix_sort(int arr[], int len) { int bit = max_bit(arr, len); int * tmpArr = (int *)malloc(sizeof(int)*len); int * countArr = (int *)malloc(sizeof(int)*10); int radix = 1; for(int i=1; i=0; --j) { int k = (arr[j]/radix)%10; tmpArr[countArr[k]-1] = arr[j]; countArr[k]--; } // 将临时数组的内容复制到原数组中 for(int j=0; j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-12 08:49:06 "},"slides/ch03.html":{"url":"slides/ch03.html","title":"第三章：枚举","keywords":"","body":"第3章 枚举 把问题所有可能的解一一进行检验，排除后得到正确可行解的过程称为枚举，这种方法是牺牲时间和空间来换取较高的准确性，所以当可能的解范围较大时，一般不建议使用这种方法。 枚举的时间复杂度一般为所有可能解的范围，但在绝大多数情况下，可以进行优化处理，缩小可能解的范围，或者根据问题的相关性质有选择性的跳跃搜索正解。 枚举简单粗暴，当可能的解范围确定时，暴力枚举所有可能的解，使用枚举算法时，要保证可能的解范围确定，并且一定能在这个范围内找到正解，其本质上就是搜索。 3.1 水仙花数 [题面] 水仙花数是指一个 n 位数（n \\geq 3），它每个位上的数字的 n 次幂之和等于它本身（如 1^3+5^3+3^3=153 ），求出所有三位数的水仙花数。 [输入] 无输入。 [输出] 从小到大顺序输出所有水仙花数，每行输出一个水仙花数。 [思路1] 直接遍历100~999，判断每个数是否满足是水仙花数的条件。判断的时候把每个数拆分出个位、十位、百位，然后判断是否满足。 [思路2] 利用三重循环，分别模拟个位、十位、百位，然后输出满足条件的数。 3.2 百钱买百鸡 [题面] 元前五世纪，我国古代数学家张丘建在《算经》一书中提出了“百鸡问题”：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 本程序要求解的问题是：给定一个正整数n，用n文钱买n只鸡，问公鸡、母鸡、小鸡各买多少只？ [输入] 输入一个正整数 n(n。 [输出] 如果有解，每种组合占一行，包含公鸡、母鸡、小鸡的个数，用正整数表示，每个数据占4列。公鸡母鸡小鸡个数均大于等于0，按公鸡数目从小到大输出，公鸡数目相同按母鸡数目从小到大输出，以此类推。如果无解，输出“No Answer”。 [样例输入] 100 [样例输出] 0 25 75 4 18 78 8 11 81 12 4 84 [思路1] 根据题意，假设 x 只公鸡， y 只母鸡， z 只小鸡，可以得到方程组 \r \\begin{cases} \r \t5x+3y+z/3 = n \\\\\r \tx+y+z = n\r \\end{cases}\r 其中， 0 \\leq x,y,z \\leq n \\ \\ \\& \\& \\ \\ z \\% 3 == 0 ，然后可以对其进行一一枚举。 [思路2] 通过已知条件对方法1进行优化，减少枚举次数。3种鸡的总数是固定的，只需要枚举公鸡和母鸡，即可确定小鸡的数量 z == n-x-y ，这样就缩小了枚举范围，去掉一个未知数，得到 \r \\begin{cases}\r \t7x+4y=n \\\\\r \tx+y+z=n\r \\end{cases}\r 其中， 0 \\leq x,y,z \\leq n \\ \\ \\& \\ \\ z \\% 3 == 0 中的 x 值可以缩小范围为 0 \\leq x \\leq \\frac{n}{4} 。 [参考代码] #include int main(void) { int n, x, y, z; scanf(\"%d\", &n); for(x=0; x=0) { y /= 4; z = 100-x-y; if(z%3==0 && 5*x+3*y+z/3==n) printf(\"%d %d %d\\n\", x, y, z); } } return 0; } 3.3 完美立方 [题面] 形如 a^3 = b^3 + c^3 + d^3 的等式被称为完美立方等式。例如 12^3 = 6^3 + 8^3 + 10^3 。编写一个程序，对任给的正整数 N(N \\leq 100) ，寻找所有的四元组 (a, b, c, d) ，使得 a^3= b^3 + c^3 + d^3 ，其中a,b,c,d 大于 1, 小于等于N，且 b \\leq c \\leq d。 [输入] 一个正整数 N (N \\leq 100)。 [题面] 每行输出一个完美立方。 输出格式为： Cube = a, Triple = (b,c,d) 其中a，b，c，d所在位置分别用实际求出四元组值代入。 请按照a的值，从小到大依次输出。当两个完美立方等式中a的值相同，则b值小的优先输出，仍相同则c值小的优先输出，再相同则d值小的先输出。 [样例输入] 24 [样例输出] Cube = 6, Triple = (3,4,5) Cube = 12, Triple = (6,8,10) Cube = 18, Triple = (2,12,16) Cube = 18, Triple = (9,12,15) Cube = 19, Triple = (3,10,18) Cube = 20, Triple = (7,14,17) Cube = 24, Triple = (12,16,20) [思路] 使用四重循环枚举a、b、c、d，a在最外层，d在最里层，每一层都是从小到大枚举。 a的枚举范围：[ 2, N ] b的枚举范围：[ 2, a-1 ] c的枚举范围：[ b, a-1 ] d的枚举范围：[ c, a-1 ]​ [参考代码] #include int main(void) { int n; scanf(\"%d\", &n); for(int a=2; a 3.4 生理周期 [题面] 人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为23天、28天和33天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为10，下次出现三个高峰同天的时间是12，则输出2（注意这里不是3）。 [输入] 多组数据。一行包含四个整数：p, e, i和d，相邻两个整数之间用单个空格隔开。 p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于p, e, 或 i。 所有给定时间是非负的并且小于等于365, 所求的时间小于等于21252。 [输出] 对每组数据输出一行，每行一个整数，即从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。 [样例输入] 0 0 0 0 0 0 0 100 5 20 34 325 4 5 6 7 283 102 23 320 203 301 203 40 [样例输出] 21252 21152 19575 16994 8910 10789 [思路] 从d+1天开始，一直试到第21252天，对其中每个日期k，看是否满足如下条件。 (k-p) \\% 23 == 0 \\ \\ \\&\\&\\ \\ (k-e) \\% 28 == 0 \\ \\ \\&\\& \\ \\ (k-i) \\% 33 == 0 根据题意，对算法进行优化即可。 [参考代码] #include int main(void) { int p, e, i, d; while(~scanf(\"%d %d %d %d\", &p, &e, &i, &d)) { int k; for(k=d+1; (k-p)%23; ++k); for(; (k-e)%28; k+=23); for(; (k-i)%33; k+=23*28); printf(\"%d\\n\", k-d); } return 0; } 3.5 假币问题 赛利有12枚银币。其中有11枚真币和1枚假币。假币看起来和真币没有区别，但是重量不同。但赛利不知道假币比真币轻还是重。于是他向朋友借了一架天平。朋友希望赛利称三次就能找出假币并且确定假币是轻是重。例如：如果赛利用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果赛利用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。经过精心安排每次的称量，赛利保证在称三次后确定假币。 [输入] 第一行有一个数字n，表示有n组测试用例。 对于每组测试用例： 输入有三行，每行表示一次称量的结果。赛利事先将银币标号为A-L。每次称量的结果用三个以空格隔开的字符串表示：天平左边放置的硬币 天平右边放置的硬币 平衡状态。其中平衡状态用\"up\"，\"down\"， 或 \"even\"表示，分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。 [输出] 输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)。 [样例输入] 1 ABCD EFGH even ABCI EFJK up ABIJ EFGH even [样例输出] K is the counterfeit coin and it is light. [思路] 对每一枚硬币先假设它是轻的，看这样是否符合称重的结果，如果符合，问题即解决。如果不符合，就假设它是重的，看是否符合称重的结果。把所有的硬币都试一遍，一定能找到特殊的硬币。 [参考代码] #include #include char left[3][13]; // 天平左边的硬币 char right[3][13]; // 天平右边的硬币 char result[3][6]; // 结果 // light为1表示假设假币为轻，0表示为重 int isFake(char c, int light) { for(int i=0; i 3.6 猜数字 [题面] 猜数字游戏是gameboy最喜欢的游戏之一。游戏的规则是这样的：计算机随机产生一个四位数，然后玩家猜这个四位数是什么。每猜一个数，计算机都会告诉玩家猜对几个数字，其中有几个数字在正确的位置上。 比如计算机随机产生的数字为1122。如果玩家猜1234,因为1,2这两个数字同时存在于这两个数中，而且1在这两个数中的位置是相同的，所以计算机会告诉玩家猜对了2个数字，其中一个在正确的位置。如果玩家猜1111,那么计算机会告诉他猜对2个数字，有2个在正确的位置。 现在给你一段gameboy与计算机的对话过程，你的任务是根据这段对话确定这个四位数是什么。 [输入] 输入数据有多组。每组的第一行为一个正整数N(1 \\leq N \\leq 100)，表示在这段对话中共有N次问答。在接下来的N行中，每行三个整数A,B,C。gameboy猜这个四位数为A，然后计算机回答猜对了B个数字，其中C个在正确的位置上。当N=0时，输入数据结束。 [输出] 每组输入数据对应一行输出。如果根据这段对话能确定这个四位数，则输出这个四位数，若不能，则输出“Not sure”。 [样例输入] 6 4815 2 1 5716 1 0 7842 1 0 4901 0 0 8585 3 3 8555 3 2 2 4815 0 0 2999 3 3 0 [样例输出] 3585 Not sure [思路] 因为随机产生的数一定是四位数，所以求解范围不大，可以使用枚举的方法。对于每一个四位数，判断其是否与输入中的对话冲突，但是在找到一个符合条件的数时，仍要继续枚举，指导出现第二个符合条件的数或者枚举完所有的四位数时，枚举结束。当有两个符合条件的数或者枚举结束都没找到一个符合条件的数时，输出“Not sure”，当且仅有一个符合条件数时，输出这个数。 [参考代码] #include #include const int N = 110; struct Arr{ int a,b,c; } arr[N]; int hashA[10], hashB[10]; int judge(int y, int n) { memset(hashA, 0, sizeof(hashA)); int A1, B1, C1, D1, A2, B2, C2, D2; A1 = y%10; hashA[A1]++; B1 = y/10%10; hashA[B1]++; C1 = y/100%10; hashA[C1]++; D1 = y/1000; hashA[D1]++; for(int i=0; i 3.7 熄灯问题 [题面] 有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。 在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。 请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。 [输入] 5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。 [输出] 5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。 [样例输入] 0 1 1 0 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 1 0 1 0 1 1 1 0 0 [样例输出] 1 0 1 0 0 1 1 1 0 1 0 1 0 0 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 [思路] 按下按钮顺序不影响最终结果； 按下一个按钮两次等价于没有按这个按钮，故每个按钮最多只需按一次。 一共30个开关，那么状态数是2^{30}，需要减少枚举的状态数目。 基本思路：如果存在某个局部，一旦这个局部状态被确定，那么剩余其它部分的状态只能是确定的一种，或者不多的n种，那么就只需枚举这个局部的状态即可。 经过观察，发现第1行就是这样一个“局部”。 因为第1行的各开关状态确定的状态下，这些开关作用过后，将导致第1行某些灯是亮的，某些灯是灭的。 要熄灭第1行某个亮着的灯（假设位于第i列），那么唯一的方法就是第2行第i列的按钮。（因为第1行的开关已经用过了，而第3行及其后面的开关不会影响到第1行） 为了使第1行的灯全部熄灭，第2行的合理开关状态就是唯一的。 枚举第1行状态数是2^6，同理枚举第1列状态数是2^5。 因为按钮状态只有开关两种，所以在是现实时可以通过位运算来实现。 [参考代码] #include #include int get_bit(char c, int i) { return (c >> i) & 1; } void set_bit(char &c, int i, int v) { if(v) c |= (1 0) flip_bit(lights[i], j-1); // 更改开关位置灯状态 flip_bit(lights[i], j); // 更改右等状态 if(j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-12 08:49:06 "},"slides/ch04.html":{"url":"slides/ch04.html","title":"第四章：递归","keywords":"","body":"第4章 递归 一个函数直接或者间接调用自己本身，这种函数称为递归函数，而递归算法是把问题转化为规模缩小了的同类问题的子问题，然后调用递归函数表示问题的解，其思想是将一个大型而且复杂的问题层层简化，转化为一个与原问题相似的规模较小且简单的子问题，通过多次调用子问题得到最终复杂问题的解。 在递归调用的过程中，系统为每一层的返回点、局部变量等开辟了栈来存储，为了避免栈溢出的问题，递归需要有边界条件，必须有一个明确的递归出口。 4.1 母牛的故事 [题面] 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第 n 年的时候，共有多少头母牛？ [输入] 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数 n(0，n 的含义如题目中描述。 n=0 表示输入数据的结束，不做处理。 [输出] 对于每个测试实例，输出在第 n 年的时候母牛的数量。 每个输出占一行。 [样例输入] 2 4 5 0 [样例输出] 2 4 6 [思路] 假设第 n 年母牛数为 cow[n]，根据题意可以知道 cow[1] =1， cow[2] = 2， cow[3] = 3；当 n>3 时，就要推公式再进行递归求解。第 n 年的母牛数可以分为两部分；第一部分为第 n-1 年的母牛总数；第二部分为第 n 年年初刚生育的小牛数，而第 n 年年初刚生育的小牛数等于第 n-3 年的母牛总数。所以，当 n>3 时，cow[n] = cow[n-1] + cow[n-3]。 为了减少不必要的重复递归，可以使用数组 cow[i] 进行记忆化递归。 [参考代码] #include int cow[60] = {0}; int cowNumber(int n) { if(cow[n]) return cow[n]; if(n 4.2 汉诺塔问题 [题面] 法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。 不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有 n 片，移动次数是f(n)。 显然 f(1)=1,f(2)=3,f(3)=7，且 f(k+1)=2*f(k)+1。此后不难证明 f(n)=2^n-1。n=64时， 假如每秒钟一次，共需多长时间呢？一个平年365天有31536000秒，闰年366天有31622400秒，平均每年31556952秒，计算一下： 18,446,744,073,709,551,615秒 这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 [输入] 输入为一个整数后面跟三个单字符字符串。 整数为盘子的数目，后三个字符表示三个杆子的编号。 [输出] 输出每一步移动盘子的记录。一次移动一行。 每次移动的记录为例如3:a->b 的形式，即把编号为3的盘子从a杆移至b杆。 我们约定圆盘从小到大编号为 1, 2, ...n。即最上面那个最小的圆盘编号为1，最下面最大的圆盘编号为 n。 [样例输入] 3 a b c [样例输出] 1:a->c 2:a->b 1:c->b 3:a->c 1:b->a 2:b->c 1:a->c [思路] 解法的基本思想是递归。假设有A、B、C三个塔，A塔有N块盘，目标是把这些盘全部移到C塔。那么先把A塔顶部的N-1块盘移动到B塔，再把A塔剩下的大盘移到C，最后把B塔的N-1块盘移到C。 每次移动多于一块盘时，则再次使用上述算法来移动。 [参考代码] #include // 将src座上的n个盘子以mid座为中转移动到dest座， // src座上最上方盘子编号是src_n void hanoi(int n, char src, char mid, char dest, int src_n) { if(n == 1) { // 只需移动一个盘子，直接将盘子从src移动到dest即可 printf(\"%d:%c->%c\\n\", src_n, src, dest); return; } // 先将n-1个盘子从src移动到mid hanoi(n-1, src, dest, mid, src_n); // 再将第n个盘子从src移动到dest printf(\"%d:%c->%c\\n\", src_n+n-1, src, dest); // 最后将n-1个盘子从mid移动到dest hanoi(n-1, mid, src, dest, src_n); return ; } int main(void) { char a, b, c; int n; scanf(\"%d %c %c %c\", &n, &a, &b, &c); hanoi(n, a, b, c, 1); return 0; } 4.3 逆波兰表达式 [题面] 逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的逆波兰表示法为* + 2 3 4。本题求解逆波兰表达式的值，其中运算符包括+ - * /四个。 [输入] 输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 [输出] 输出为一行，表达式的值。 可直接用printf(\"%f\\n\", v)输出表达式的值v。 [样例输入] * + 11.0 12.0 + 24.0 35.0 [样例输出] 1357.000000 [提示] 样例输入含义：(11.0+12.0)*(24.0+35.0) 可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在stdlib.h中。 此题可使用函数递归调用的方法求解。 [思路] 本题中“逆波兰表达式”的定义： 一个数是一个逆波兰表达式，值为该数 \"运算符 逆波兰表达式 逆波兰表达式\" 是逆波兰表达式，值为两个逆波兰表达式的值运算的结果 一般教科书将本题中的“逆波兰表达式”称为“波兰表达式”，而将运算符后置的表达式成为“逆波兰表达式” [参考代码] #include #include double exp() { char s[100]; scanf(\"%s\", s); switch(s[0]) { case '+': return exp() + exp(); case '-': return exp() - exp(); case '*': return exp() * exp(); case '/': return exp() / exp(); default: return atof(s); } } int main(void) { printf(\"%f\\n\", exp()); return 0; } 4.4 N皇后问题 [题面] 在 N*N 的方格棋盘放置了 N 个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。 你的任务是，对于给定的 N，求出有多少种合法的放置方法。 [输出] 共有若干行，每行一个正整数 N≤10，表示棋盘和皇后的数量；如果 N=0，表示结束。 [输出] 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 [样例输入] 1 8 5 0 [样例输出] 1 92 10 [思路] 通过递归逐层枚举皇后存放位置即可，具体过程看代码注释。 [参考代码] #include #include // 用来存放算好的皇后位置，最左上角是(0,0) int queenPos[100]; // counts[i]=j 表示i个皇后时摆放情况有j个 int counts[10]; // 在0~k-1 行皇后已经摆好的情况下，摆第k行及其后的皇后 void putQueen(int k, int n) { // N 个皇后已经摆好 if(k == n) { counts[n]++; return ; } // 逐列尝试寻找第k个皇后的位置 for(int i=0; i 4.5 EOF牛肉串 [题面] 今年的ACM暑期集训队一共有18人，分为6支队伍。其中有一个叫做EOF的队伍，由04级的阿牛、XC以及05级的COY组成。在共同的集训生活中，大家建立了深厚的友谊，阿牛准备做点什么来纪念这段激情燃烧的岁月，想了一想，阿牛从家里拿来了一块上等的牛肉干，准备在上面刻下一个长度为n的只由\"E\" \"O\" \"F\"三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）,阿牛同时禁止在串中出现O相邻的情况，他认为，\"OO\"看起来就像发怒的眼睛，效果不好。 你能帮阿牛算一下一共有多少种满足要求的不同的字符串吗？ [输入] 输入数据包含多个测试实例,每个测试实例占一行，由一个整数 n 组成，(0。 [输出] 对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。 [样例输入] 1 2 [样例输出] 3 8 [思路] 因为两个 O 不能连在一起，所以考虑两种单独的情况。设长度为 n 时的 x[n]=a[n]+b[n]，其中，a[n] 代表长度为 n 时末尾为 O 的情况总和， b[n] 代表长度为 n 时末尾不为 O 的情况总和。 那么分情况讨论： 当长度为 n，末尾为 O 时，再加一个单位的长度有两种加法，即 E，F。 当长度为 n，末尾不为 O 时，再加一个单位的长度有三种加法，即 E，O，F。 所以 x[n+1] = a[n+1] + b[n+1] = 2*a[n] + 3*b[n] = 2*x[n] + b[n] 。 而 b[n] 又由 x[n-1] 推来，x[n-1] = a[n-1] + b[n-1]，在长度为 n-1 且末尾为 O 时，要将它变成长度为 n 且末尾不为 O 有两种方法（E，F），即 2*a[n-1]​。 同理，在长度为 n-1 且末尾不为 O 时，要将它变成长度为 n 且末尾不为 O 有两种方法（E，F），即 2*b[n-1]。 所以 x[n+1] = 2*x[n] + b[n] = 2*x[n] + 2*x[n-1]。 [参考代码] #include int main(void) { long long arr[50] = {0}; arr[1] = 3; arr[2] = 8; for(int i=3; i 4.6 RPG难题 [题面] 著名的RPG难题: 有排成一行的 ｎ 个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色。求全部的满足要求的涂法。 [输入] 输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0 [输出] 对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。 [样例输入] 1 2 [样例输出] 3 6 [思路] 当长度为 n 时，满足要求的涂法为 x[n]，设3中颜色为A、B、C，由 x[n] 推出 x[n+1]。 若长度为 n 时，序列为 ABC···BAC，那么在后面加一个，只有一种加法，因为既要与开头不一样，又要与末尾不一样，所以只能加 B，因此从 n 变为 n+1 只有一种方法。 然而，还有种情况忽略了，就是当长度为 n-1 时，序列为 ABC···CB 时，若在其后加一个 A 变成 ABC···CBA 是不符合题意的，但可以在后面加两个让其变得有意义，如 ABC···CBAC 或者 ABC···CBAB，可得出从 n-1 变为 n+1 有两种方法。 所以，可以退出公式 x[n] = x[n-1] + 2*x[n-2]。 [参考代码] #include int main(void) { long long arr[60] = {0}; arr[1] = 3; arr[2] = arr[3] = 6; for(int i=4; i 4.7 放苹果 [题面] 把 M 个同样的苹果放在 N 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。 [输入] 第一行是测试数据的数目 t(0 \\leq t \\leq 20)。以下每行均包含二个整数 M 和 N ，以空格分开。1 \\leq M，N \\leq 10。 [输出] 对输入的每组数据 M 和 N ，用一行输出相应的K。 [样例输入] 1 7 3 [样例输出] 8 [思路] 设 M 个苹果放在 N 个盘子里放法总数是 f(M,N)，则： N > M 时，f(M,N) = f(M,M) N 时，总放法 = 有盘子为空的放法 + 没盘子为空的放法 f(M,N) = f(M,N-1) + f(M-N,N) 边界条件：当苹果数为0时，1种放法；当盘子数为0时，0种放法。 [参考代码] #include int f(int m, int n) { if(n > m) return f(m, m); if(m == 0) return 1; if(n 4.8 算24 [题面] 给出4个小于10个正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。 这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。 比如，对于5，5，5，1，我们知道 5 * (5 – 1 / 5) = 24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到 24。 [输入] 输入数据包括多行，每行给出一组测试数据，包括4个小于10个正整数。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。 [输出] 对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。 [样例输入] 5 5 5 1 1 1 4 2 0 0 0 0 [样例输出] YES NO [思路] n 个数算 24 ，必有两个数要先算。这两个数算的结果，和剩余 n-2 个数，就构成了 n-1 个数求 24 的问题。 枚举先算的两个数，以及这两个数的运算方式。 边界条件：一个数算 24 注意：浮点数不能直接判等。 [参考代码] #include #include #include #define EPS 1e-6 int isZero(double x) { return fabs(x) 4.9 *四则运算表达式求值 [题面] 求一个可以带括号的小学算术四则运算表达式的值。 [输入] 一行，一个四则运算表达式。'*'表示乘法，'/'表示除法。 [输出] 一行，该表达式的值，保留小数点后面两位。 [样例输入1] 3.4 [样例输出1] 3.40 [样例输入2] 7+8.3 [样例输出2] 15.30 [样例输入3] 3+4.5*(7+2)*(3)*((3+4)*(2+3.5)/(4+5))-34*(7-(2+3)) [样例输出3] 454.75 [思路] 表达式是一个递归定义，因此可对表达式进行递归分析处理。 [参考代码] #include #include #include #include using namespace std; double expression_value(); double term_value(); double factor_value(); // 获取一个表达式的值 double expression_value() { // 求第一项的值 double result = term_value(); while(1) { // 从缓存区获取一个字符，并不从缓存区取走 char op = cin.peek(); if('+'==op || '-'==op) { // 从缓存区读出运算符 cin.get(); // 从缓存区读取另一项的值 double value = term_value(); if('+' == op) result += value; else result -= value; } else break; } return result; } // 获取一个项的值 double term_value() { // 求第一个因子的值 double result = factor_value(); while(1) { char op = cin.peek(); if('*'==op || '/'==op) { // 从缓存区读出运算符 cin.get(); // 读取运算符后的另一个因子的值 double value = factor_value(); if('*' == op) result *= value; else result /= value; } else break; } return result; } // 获取一个因子的值 double factor_value() { double result = 0; char c = cin.peek(); if('(' == c) { cin.get(); // 从缓存区读出 '(' // 读取括号中表达式的值 result = expression_value(); cin.get(); // 从缓存区读出 ')' } else { // 读取小数点前面数值 while(isdigit(c)) { result = result*10 + (c-'0'); cin.get(); c = cin.peek(); } // 如果存在小数点读取小数点后面数值 if('.' == c) { cin.get(); c = cin.peek(); double f = 0.1; while(isdigit(c)) { result = result + (c-'0')*f; f *= 0.1; cin.get(); c = cin.peek(); } } } return result; } int main(void) { printf(\"%.2lf\\n\", expression_value()); return 0; } Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-12 08:49:06 "},"slides/ch05.html":{"url":"slides/ch05.html","title":"第五章：贪心","keywords":"","body":"第5章 贪心 贪心算法是指在对问题求解时，总是选取当前最优策略的算法，其不是从整体上考虑，而是从某种意义上得到局部的最优解，使用贪心算法时，一定要保证无后效性，即当前选择的状态不会对以后的状态产生影响。 求解时，把问题分为若干个子问题进行求解，得到子问题的局部最优解，因为其满足无后效性，局部最优解能导致全局最优解。 5.1 圣诞老人的礼物 [题面] 圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。 [输入] 第一行由两个部分组成，分别为糖果箱数正整数 n(1 \\leq n \\leq 100)，驯鹿能承受的最大重量正整数 w(0 ，两个数用空格隔开。其余 n 行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数 v 和重量正整数 w ，中间用空格隔开。 [输出] 输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。 [样例输入] 4 15 100 4 412 8 266 7 591 2 [样例输出] 1193.0 [思路] 按礼物的 价值/重量 比从大到小依次选取礼物，对选取的礼物尽可能多地装，直到达到总重量 w 。 [参考代码] #include #include using namespace std; const double eps = 1e-6; struct Candy { int v; int w; bool operator eps; } } candies[110]; int main(void) { int n, w; scanf(\"%d %d\", &n, &w); for(int i=0; i 5.2 电影节 [题面] 大学生电影节在北大举办! 这天，在北大各地放了多部电影，给定每部电影的放映时间区间，区间重叠的电影不可能同时看（端点可以重合），问李雷最多可以看多少部电影。 [输入] 多组数据。每组数据开头是 n(n \\leq 100)，表示共 n 场电影。 接下来 n 行，每行两个整数(0到1000之间)，表示一场电影的放映区间。 n=0 则数据结束。 [输出] 对每组数据输出最多能看几部电影 [样例输入] 8 3 4 0 7 3 8 15 19 15 20 10 15 8 18 6 12 0 [样例输出] 3 [思路] 将所有电影按结束时间从小到大排序，第一步选结束时间最早的那部电影。然后，每步都选和上一部选中的电影不冲突且结束时间最早的电影。 [参考代码] #include #include #include using namespace std; struct film{ int s; int e; bool operator= endtime){ endtime = films[i].e; sum++; } } printf(\"%d\\n\", sum); } return 0; } 5.3 做作业 [题面] Ignatius有很多作业要做，每门作业都有一个最迟期限，如果没有在最迟期限内完成，就会扣除相应的分数。假设做每门作业都要一天时间，你能帮他规划出扣分最少的做作业顺序吗？ [输入] 输入包含多组测试数据。输入的第一行为一个数 T，表示测试组数，接下来包括 T 组测试数据，每组测试数据的第一行为一个整数 N(1 \\leq N \\leq 1000)，表示作业门数，接下来有两行，第一行有 N 个数字，分别表示每门作业的最迟期限，第二行有 N 个数字，分别表示未完成作业扣除的相应分数。 [输出] 对于每组测试数据，输出扣除的最少分数，每行对应一个数据答案。 [样例输入] 3 3 3 3 3 10 5 1 3 1 3 1 6 2 3 7 1 4 6 4 2 4 3 3 2 1 7 6 5 4 [样例输出] 0 3 5 [思路] 题目中求解扣除的最少分数，那么从分数下手，优先完成分数高的作业，所以将作业按照分数进行排序，其次考虑怎样安排顺序。 作业: A B C D E F G 期限: 1 4 6 4 2 4 3 扣分: 3 2 1 7 6 5 4 用样例3来分析，假设第一天做了“作业A”，第二天做了“作业E”，第三天做了“作业G”，那么第四天会选择扣分更高的“作业D”，若这样安排，第四天会产生扣分7（“作业B” + “作业F”），很明显不是最优解。 其实可以用第三天做“作业F”，第一天做“作业G”，这样就能达到最优解，所以我们不能正向考虑，应该把时间用来做尽可能扣分高的作业，直接按照时间从大到小进行枚举，判断在最迟期限前是否能完成它，需要用到一个标记数组来辅助判断该天是否已被占用。 [参考代码] #include #include #include #include const int N = 1010; struct Work { int time; int score; friend bool operator b.score; } } workArr[N]; int doneArr[N]; int main(void) { int t, n; scanf(\"%d\", &t); while(t--) { scanf(\"%d\", &n); for(int i=0; i 5.4 保护花园 [题面] 农夫去砍柴，留下了 N(2 \\leq N \\leq 100,000) 头牛吃草，等农夫砍柴回来发现所有的牛都在花园中破坏花朵。农夫决定依次将每头牛牵回牛棚，但在这个过程中，其它仍留在花园中的牛会继续破坏花朵，牵一头牛回牛棚的单程时间为 Ti(1 \\leq Ti \\leq 2,000,000)，牛在花园中每分钟破坏花朵数为 Di(1 \\leq Di \\leq 100) 。请编写一段程序，决定牵牛回牛棚的顺序以保证破坏的总花朵数最少。 [输入] 第一行：一个整数 N 。 第二行到第N+1行：每一行包括两个整数，分别表示为 Ti 和 Di 。 [输出] 输出一个数字表示被破坏的最少花朵数。 [样例输入] 6 3 1 2 5 2 3 3 2 4 1 1 6 [样例输出] 86 [思路] 因为牵一头牛的单程时间是 Ti ，当把一头牛牵到牛棚再回来牵第二头牛的时间为 2*Ti ，假设两头牛分别为 CowX、CowY，分别对应 CowXt、CowXd、CowYt、CowYd 。 如果先牵 CowX，那么被破坏的花朵数为 2 * CowXt * CowYd 。 如果先牵 CowY，那么被破坏的花朵数为 2 * CowYt * CowXd 。 对于上面两个式子同时除以 2 * CowXt * CowYt 可以分别得到 \\frac{CowYd}{CowYt}，\\frac{CowXd}{CowXt} 。 那么当 \\frac{CowYd}{CowYt} 时，表示先牵 CowX 更优，反之则牵 CowY 更优，综上把每头牛的 Di 和 Ti 相除按照从大到小的顺序排序，再枚举可求值。 [参考代码] #include #include typedef long long ll; const int N = 100010; struct Cow { int t; int d; friend bool operator 1.0*b.d/b.t; } } cowArr[N]; int main(void) { int n; scanf(\"%d\", &n); ll sumD = 0; for(int i=0; i 5.5 畜栏保留问题 [题面] 农场有 N 头牛，每头牛会在一个特定的时间区间 [A, B]（包括A和B）在畜栏里挤奶，且一个畜栏里同时只能有一头牛在挤奶。现在农场主希望知道最少几个畜栏能满足上述要求，并要求给出每头牛被安排的方案。对于多种可行方案，主要输出一种即可。（Special judged） 去同一个畜栏的两头牛，它们挤奶时间区间哪怕只在端点重合也是不可以的。 [输入] 输入的第一行包含一个整数 N(1 \\leq N \\leq 50, 000)，表示有 N 牛头；接下来 N 行每行包含两个数，分别表示这头牛的挤奶时间 [Ai, Bi] (1 \\leq A \\leq B \\leq 1, 000, 000)。 [输出] 输出的第一行包含一个整数，表示最少需要的畜栏数；接下来 N 行，第 i+1 行描述了第 i 头牛所被分配的畜栏编号（从1开始）。 [样例输入] 5 1 10 2 4 3 6 5 8 4 7 [样例输出] 4 1 2 3 2 4 [思路] 所有奶牛都必须挤奶。到了一个奶牛的挤奶开始时间，就必须为这个奶牛找畜栏。因此按照奶牛的开始时间逐个处理它们，是必然的。 S(x)表示奶牛x的开始时间。E(x)表示x的结束时间。对E(x), x可以是奶牛，也可以是畜栏。畜栏的结束时间，就是正在其里面挤奶的奶牛的结时间。同一个畜栏的结束时间是不断在变的。 把所有奶牛按开始时间从小到大排序。 为第一头奶牛分配一个畜栏。 依次处理后面每头奶牛i。处理i 时，考虑已分配畜栏中，结束时间最早的畜栏x。 若E(x) 若E(x) >= S(i)，则分配新畜栏y，记E(y) = E(i)。 直到所有奶牛处理结束。 需要用优先队列存放已经分配的畜栏，并使得结束时间最早的畜栏始终位于队列头部。 [参考代码] #include #include #include using namespace std; // 奶牛结构体 struct Cow { int s; // 开始挤奶时间 int e; // 结束挤奶时间 int no; // 奶牛编号 friend bool operator s2.end; } }; int main(void) { int n; scanf(\"%d\", &n); for(int i=0; i pQueue; for(int i=0; i 5.6 放置雷达 [题面] 假设海岸是一条直线。陆地在海岸的一侧，海洋在海岸的另外一侧。每个岛屿都是海边的一个点。雷达装置只能安装在海岸上，当一个雷达装置到岛屿的距离不超过 d （整数），则认为该雷达覆盖了该 岛屿。 使用笛卡尔积坐标系，定义海岸是 x 轴，海洋位于 x 轴上方，陆地位于 x 轴下方。给定海洋中每个岛屿的位置，并告知雷达装置的覆盖距离，请编写程序求出至少需要多少个雷达装置才能够覆盖所有的岛屿。 [输入] 输入包含多组测试用例。 每组测试用例的第一行都包含两个整数 n(1 \\leq n \\leq 1000) 和 d，其中 n 是海洋中的岛屿数量，d 是雷达设备的覆盖距离。之后 n行，每行包含两个表示每个岛的位置坐标（x, y）的整数。 以空白行分隔多组测试用例。输入一组0时表示输入结束。 [输出] 对于每组测试用例进行输出，一行由测试用例编号和所需的最少雷达安装数组成。“ -1”意味着在这种情况下没有解决方案。 [样例输入] 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 [样例输出] Case 1: 2 Case 2: 1 [思路] 对每个岛屿P，可以算出覆盖它的雷达必须位于x轴上的区间 [P_s,P_e]。如果有雷达位于某个x轴区间 [a,b]，称该雷达覆盖此区间。 问题转换为，至少要在x轴上放几个雷达（点），才能覆盖全部区间 [P1_s,P1_e]，[P2_s,P2_e] ... [Pn_s,Pn_e] 。 如果可以找到一个雷达同时覆盖多个区间，那么把这多个区间按终点坐标从小到大排序，则第一个区间（终点最靠左的）的终点，就能覆盖所有区间。 有了这个结论，就可以只挑区间的终点来放置雷达了。 [参考代码] #include #include #include using namespace std; struct Range { double l, r; bool operator d) noAnswer=1; } if(noAnswer) { printf(\"Case %d: %d\\n\", k++, -1); continue; } sort(arr, arr+n); int count = 1; double maxR = arr[0].r; for(int i=0; i maxR) { maxR = arr[i].r; count++; } } printf(\"Case %d: %d\\n\", k++, count); } return 0; } 5.7 钓鱼 [题面] John要去钓鱼了。他共有 h \\; (1 \\leq h \\leq 16) 个小时的时间来进行钓鱼，并且钓鱼区域有 n \\; (2 \\leq n \\leq 25) 个湖泊可以通过一条单向路径到达。John从1号湖泊开始钓鱼，从任何位置结束钓鱼。他只能从一个湖泊到另一个湖泊单向行走，只要他愿意他可以不在任何一个湖上停留。对于每个 i = 1，...，n-1 ，从 湖泊i 到 湖泊i + 1 耗时 ti \\; (0 个时间片（每个时间片5分钟）。例如，t3 = 4 意味着从 湖泊3 到 湖泊4 需要20分钟。 为计划完成他的钓鱼之旅，John收集了关于湖泊的信息。对于每个 湖泊i，已知在最初5分钟内将钓到鱼的数量表示为 fi \\; (fi \\geq 0)。每钓鱼5分钟，下一个5分钟间隔内预期钓到鱼的数量将以恒定的 di \\; (di \\geq 0) 的速率减少。如果预计在一个间隔中钓到鱼的数量小于或等于 di，则在下一个间隔中当前湖泊中将不再有鱼上钩。为了简化计划，John假设其他人都不会在湖边钓鱼，以影响他的钓鱼数量。 编写程序帮助John完成他的钓鱼之旅，以最大程度地提高预期钓鱼数量。在每个湖上花费的分钟数必须是5的倍数。 [输入] 输入中将提供多组测试用例。 每组测试用例第一行输入 n ，第二行输入 h 。接下来一行中输入 n 个整数表示 fi \\; (1 \\leq i \\leq n)，然后一行输入 n 个整数表示 di \\; (1 \\leq i \\leq n)，最后一行 n-1 个整数表示 ti \\; (1 \\leq i \\leq n-1)。 如果输入 n = 0 时表示输入结束。 [输出] 对于每组测试用例，请打印每个湖泊所花费的分钟数（以逗号分隔，逗号后面加一个空格），以使计划达到预期的最大捕捞量（即使计划超过80个字符，也应将整个计划打印在一行上）。之后一行输出预期最大钓鱼数量。 如果存在多个计划，如果有多种方案，则优先选择在第一个湖泊呆时间最长的。如果还有多种，则 优先选择在第二个湖泊呆的时间最长的，依此类推。 在每组输出之间插入空白行。 [样例输入] 2 1 10 1 2 5 2 4 4 10 15 20 17 0 3 4 3 1 2 3 4 4 10 15 50 30 0 3 4 3 1 2 3 0 [样例输出] 45, 5 Number of fish expected: 31 240, 0, 0, 0 Number of fish expected: 480 115, 10, 50, 35 Number of fish expected: 724 [思路] 本题难点是走路时间可多可少，不确定到底该花多长时间纯钓鱼才最好（可能有好湖在很右边）。 可以通过枚举最终停下来的湖，将方案分成 n 类。每类方案的走路时间就是确定的。在每类方案里找最优解，然后再优中选优。 贪心策略： 在确定停下来的湖是 x 的情况下，假定纯钓鱼时间是 k 个时间片。 用三元组 (F,i,j) (1\\leq i \\leq x, 1 \\leq j \\leq k) 表示 湖泊i 的 第j个时间片 能够钓的鱼的数目是 F 。 将所有的 (F,i,j)（共x*k个）按 F 值从大到小排序，选前 k 个，就构成了最佳钓鱼方案。 [参考代码] #include #include #include using namespace std; // 湖泊信息结构体 struct Lake { int fi; // 池塘初始5分钟内钓鱼数量 int id; // 池塘编号 int di; // 池塘每5分钟钓鱼衰减数量 // 大根堆 friend bool operator r.id; return l.fi queue; for(int j=0; j0; --time) { Lake lake = queue.top(); queue.pop(); tempFish += lake.fi; lake.fi -= lake.di; if(lake.fi maxFish) { maxFish = tempFish; for(int j=0; j Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-12 08:49:06 "},"slides/ch06.html":{"url":"slides/ch06.html","title":"第六章：深度优先搜索","keywords":"","body":"第6章 深度优先搜索 在图上寻找路径 在图上如何寻找从1到8的路径？ 一种策略：只要能发现没走过的点，就走到它。有多个点可走就随便挑一个，如果无路可走就回退，再看有没有没走过的点可走。 运气好：[1] -> [2] -> [4] -> [8] 运气一般：[1] -> [2] -> [4] -> [5] -> [6] -> [8] 运气坏：[1] -> [3] -> [7] -> [9] => [7] => [3] -> [5] -> [6] -> [8]（双线箭头表示回退） 不连通的图，无法从节点1走到节点8。 完整的尝试过程可能为：[1] -> [2] -> [4] -> [3] -> [7] => [3] => [4] => [2] -> [9] => [2] => [1] 结论：不存在从1到8的路径。得出这个结论之前，一定会把从1出发能走到的点全部都走过。 从起点出发，走过的点要做标记，发现有没走过的点，就随意挑一个往前走，走不了就回退，此种路径搜索策略就称为“深度优先搜索”，简称“深搜”。 其实称为“远度优先搜索”更容易理解些。因为这种策略能往前走一步就往前走一步，总是试图走得更远。所谓远近(或深度），就是以距离起点的步数来衡量的。 判断从V出发是否能走到终点 bool Dfs(V) { if(V为终点) return true; 将V标记为旧点; 对和V相邻的每个新节点U { if(Dfs(U) == true) return true; } return false; } int main(void) { 将所有点都标记为新点; 起点 = 1; 终点 = 8; printf(\"%s\\n\", Dfs(起点) ? \"Yes\" : \"No\"); return 0; } 判断从V出发是否能走到终点，如果能输出路径 Node path[MAX_LEN]; // MAX_LEN取节点总数即可 int depth; bool Dfs(V) { if(V为终点) { path[depth] = V; return true; } 将V标记为旧点; path[depth] = V; ++depth; 对和V相邻的每个新节点U { if(Dfs(U) == true) return true; } --depth; return false; } int main(void) { 将所有点都标记为新点; depth = 0; if(Dfs(起点)) { for(int i = 0;i 遍历图上所有节点 Dfs(V) { 将V标记为旧点; 对和V相邻的每个新点U { Dfs(U); } } int main(void) { 将所有点都标记为新点; while(在图中能找到新点k) Dfs(k); } 图的表示方法 -- 邻接矩阵 用一个二维数组G存放图，G[i][j]表示节点i和节点j之间边的情况（如有无边，边方向，权值大小等) 。 遍历复杂度：O(n^2)。 （n为节点数目） 图的表示方法 -- 邻接表 每个节点V对应一个一维数组（vector），里面存放从V连出去的边，边的信息包括另一顶点，还可能包含边权值等。 遍历复杂度：O(n+e)。 （n为节点数目，e为边数目） 6.1 城堡问题 [题面] 1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####---#####---#---#####---# 2 # # | # # # # # #---#####---#####---#####---# 3 # | | # # # # # #---#########---#####---#---# 4 # # | | | | # # ############################# # = Wall | = No wall - = No wall 上图是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成 m \\times n（m \\leq 50，n \\leq 50）个方块，每个方块可以有0~4面墙。 [输入] 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字（0 \\leq p \\leq 50）描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块（1,1）的南墙同时也是方块（2,1）的北墙。输入的数据保证城堡至少有两个房间，数据保证城堡四周都是墙。 [输出] 城堡的房间数、城堡中最大房间所包括的方块数。结果显示在标准输出设备上。 [样例输入] 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 [样例输出] 5 9 [思路] 把方块看作是节点，相邻两个方块之间如果没有墙，则在方块之间连一条边，这样城堡就能转换成一个图。 求房间个数，实际上就是在求图中有多少个极大连通子图。 一个连通子图，往里头加任何一个图里的其他点，就会变得不连通，那么这个连通子图就是 极大连通子图。 对每一个房间，深度优先搜索，从而给这个房间能够到达的所有位置染色。最后统计一共用了几种颜色，以及每种颜色的数量。 如题目描述示例中，图完色可知一共有5个房间，最大的房间（1）占据9个格子。 ############################# # 1 | 1 # 2 | 2 # 3 | 3 | 3 # #####---#####---#---#####---# # 1 # 1 | 1 # 2 # 3 # 4 # 3 # #---#####---#####---#####---# # 1 | 1 | 1 # 5 # 3 # 5 # 3 # #---#########---#####---#---# # 1 # 5 | 5 | 5 | 5 | 5 # 3 # ############################# [参考代码] #include int R,C; // 行列数 int rooms[60][60]; int color[60][60] = {0}; int maxRoomArea = 0, roomNum = 0; int totalRoomArea; void dfs(int i, int j) { if(color[i][j]) return; ++totalRoomArea; color[i][j] = roomNum; if(!(rooms[i][j]&1)) dfs(i, j-1); // 向西 if(!(rooms[i][j]&2)) dfs(i-1, j); // 向北 if(!(rooms[i][j]&4)) dfs(i, j+1); // 向东 if(!(rooms[i][j]&8)) dfs(i+1, j); // 向南 } int main(void) { scanf(\"%d%d\", &R, &C); for(int i=1; imaxRoomArea ? totalRoomArea : maxRoomArea; } } } printf(\"%d\\n\", roomNum); printf(\"%d\\n\", maxRoomArea); } 6.2 踩方格 [题面] 有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设： a. 每走一步时，只能从当前方格移动一格，走到某个相邻的方格上； b. 走过的格子立即塌陷无法再走第二次； c. 只能向北、东、西三个方向走； 请问：如果允许在方格矩阵上走 n 步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。 [输入] 允许在方格上行走的步数 n（n \\leq 20） [输出] 计算出的方案数量。 [样例输入] 2 [样例输出] 7 [思路] 递归从(i,j) 出发，走n步的方案数，等于以下三项之和： 从(i+1,j)出发，走n-1步的方案数。前提：(i+1,j)还没走过 从(i,j+1)出发，走n-1步的方案数。前提：(i,j+1)还没走过 从(i,j-1)出发，走n-1步的方案数。前提：(i,j-1)还没走过 [参考代码] #include int visited[30][50] = {0}; int ways(int i, int j, int n) { if( n == 0) return 1; int num = 0; visited[i][j] = 1; if(!visited[i][j-1]) num += ways(i, j-1, n-1); if(!visited[i][j+1]) num += ways(i, j+1, n-1); if(!visited[i+1][j]) num += ways(i+1, j, n-1); visited[i][j] = 0; return num; } int main(void) { int n; scanf(\"%d\", &n); printf(\"%d\\n\", ways(0,25,n)); return 0; } Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-10-17 17:25:40 "}}