# 第5章 贪心

贪心算法是指在对问题求解时，总是选取当前最优策略的算法，其不是从整体上考虑，而是从某种意义上得到局部的最优解，使用贪心算法时，一定要保证无后效性，即当前选择的状态不会对以后的状态产生影响。

求解时，把问题分为若干个子问题进行求解，得到子问题的局部最优解，因为其满足无后效性，局部最优解能导致全局最优解。

## 圣诞老人的礼物

**[题面]**

圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。

**[输入]**

第一行由两个部分组成，分别为糖果箱数正整数 $$n(1 \leq n \leq 100)$$，驯鹿能承受的最大重量正整数 $$w(0 < w < 10000)$$ ，两个数用空格隔开。其余 $$n$$ 行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数 $$v$$ 和重量正整数 $$w$$ ，中间用空格隔开。

**[输出]**

输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。

**[样例输入]**

```
4 15
100 4
412 8
266 7
591 2
```

**[样例输出]**

```
1193.0
```

**[思路]**

按礼物的 价值/重量 比从大到小依次选取礼物，对选取的礼物尽可能多地装，直到达到总重量 $$w$$ 。


**[参考代码]**

``` cpp
#include <stdio.h>
#include <algorithm>
using namespace std;

const double eps = 1e-6;

struct Candy {
    int v; 
    int w;
    bool operator < (const Candy & c) const { 
        return double(v)/w - double(c.v)/c.w > eps; 
    }
} candies[110];

int main(void) {
    int n, w;
    scanf("%d %d", &n, &w);
    for(int i=0; i<n; ++i)
        scanf("%d%d", &candies[i].v , &candies[i].w);
    sort(candies, candies+n);
    
    int totalW = 0;
    double totalV = 0;
    for(int i=0; i<n; ++i) {
        if(totalW + candies[i].w <= w) {
            totalW += candies[i].w;
            totalV += candies[i].v;
        }
        else {
            totalV += candies[i].v * double(w-totalW)/candies[i].w;
            break;
        }
    }
    printf("%.1f",totalV);

    return 0;
}
```


## 做作业

**[题面]**

Ignatius有很多作业要做，每门作业都有一个最迟期限，如果没有在最迟期限内完成，就会扣除相应的分数。假设做每门作业都要一天时间，你能帮他规划出扣分最少的做作业顺序吗？

**[输入]**

呼入包含多组测试数据。输入的第一行为一个数 $$T$$，表示测试组数，接下来包括 $$T$$ 组测试数据，每组测试数据的第一行为一个整数 $$N(1 \leq N \leq 1000)$$，表示作业门数，接下来有两行，第一行有 $$N$$ 个数字，分别表示每门作业的最迟期限，第二行有 $$N$$ 个数字，分别表示未完成作业扣除的相应分数。

**[输出]**

对于每组测试数据，输出扣除的最少分数，每行对应一个数据答案。

**[样例输入]**

```
3
3
3 3 3
10 5 1
3
1 3 1
6 2 3
7
1 4 6 4 2 4 3
3 2 1 7 6 5 4
```

**[样例输出]**

```
0
3
5
```

**[思路]**

题目中求解扣除的最少分数，那么从分数下手，优先完成分数高的作业，所以将作业按照分数进行排序，其次考虑怎样安排顺序。

``` 
作业: A B C D E F G
期限: 1 4 6 4 2 4 3
扣分: 3 2 1 7 6 5 4
```

用样例3来分析，假设第一天做了“作业A”，第二天做了“作业E”，第三天做了“作业G”，那么第四天会选择扣分更高的“作业D”，若这样安排，第四天会产生扣分7（“作业B” + “作业F”），很明显不是最优解。

其实可以用第三天做“作业F”，第一天做“作业G”，这样就能达到最优解，所以我们不能正向考虑，应该把时间用来做尽可能扣分高的作业，直接按照时间从大到小进行枚举，判断在最迟期限前是否能完成它，需要用到一个标记数组来辅助判断该天是否已被占用。

**[参考代码]**

``` cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>

const int N = 1010;

struct Work {
    int time;
    int score;
    friend bool operator < (const Work &a, const Work &b) {
        return a.score > b.score;
    }
} workArr[N];

int doneArr[N];

int main(void) {
    int t, n;
    scanf("%d", &t);
    while(t--) {
        scanf("%d", &n);
        for(int i=0; i<n; ++i) 
            scanf("%d", &workArr[i].time);

        for(int i=0; i<n; ++i) 
            scanf("%d", &workArr[i].score);

        // 根据扣分从大到小排序
        std::sort(workArr, workArr+n);
    
        memset(doneArr, 0, sizeof(doneArr));

        int ans = 0;
        for(int i=0; i<n; ++i) {
            // 如果最迟期限那天被占用了
            if(doneArr[workArr[i].time]) {
                int x = workArr[i].time;
                // 向前枚举寻找是否有空闲天数
                while(x && doneArr[x]) x--;
                // 如果有空闲天数则占用
                if(x) doneArr[x] = 1;
                // 没有空闲天数则累加扣分
                else ans += workArr[i].score;
            }
            else
                doneArr[workArr[i].time] = 1;
        }
        printf("%d\n", ans);
    }

    return 0;
}
```

## 保护花园

**[题面]**

农夫去砍柴，留下了 $$N(2 \leq N \leq 100,000)$$ 头牛吃草，等农夫砍柴回来发现所有的牛都在花园中破坏花朵。农夫决定依次将每头牛牵回牛棚，但在这个过程中，其它仍留在花园中的牛会继续破坏花朵，牵一头牛回牛棚的单程时间为 $$Ti(1 \leq Ti \leq 2,000,000)$$，牛在花园中每分钟破坏花朵数为 $$Di(1 \leq Di \leq 100)$$ 。请编写一段程序，决定牵牛回牛棚的顺序以保证破坏的总花朵数最少。

**[输入]**

第一行：一个整数 $$N$$ 。

第二行到第N+1行：每一行包括两个整数，分别表示为 $$Ti$$ 和 $$Di$$ 。

**[输出]**

输出一个数字表示被破坏的最少花朵数。

**[样例输入]**

```
6
3 1
2 5
2 3
3 2
4 1
1 6
```

**[样例输出]**

```
86
```

**[思路]**

因为牵一头牛的单程时间是 $$Ti$$ ，当把一头牛牵到牛棚再回来牵第二头牛的时间为 $$2*Ti$$ ，假设两头牛分别为 $$CowX$$、$$CowY$$，分别对应 $$CowXt$$、$$CowXd$$、$$CowYt$$、$$CowYd$$ 。

如果先牵 $$CowX$$，那么被破坏的花朵数为 $$2 * CowXt * CowYd$$ 。

如果先牵 $$CowY$$，那么被破坏的花朵数为 $$2 * CowYt * CowXd$$ 。

对于上面两个式子同时除以 $$2 * CowXt * CowYt$$ 可以分别得到 $$CowYd / CowYt$$，$$CowXd / CowXt$$ 。

那么当 $$CowYd / CowYt < CowXd / CowXt$$ 时，表示先牵 $$CowX$$ 更优，反之则牵 $$CowY$$ 更优，综上把每头牛的 $$Di$$ 和 $$Ti$$ 相除按照从大到小的顺序排序，再枚举可求值。

**[参考代码]**

``` cpp
#include <stdio.h>
#include <algorithm>

typedef long long ll;
const int N = 100010;

struct Cow {
    int t;
    int d;
    friend bool operator < (const Cow &a, const Cow &b) {
        return 1.0*a.d/a.t > 1.0*b.d/b.t;
    }
} cowArr[N];


int main(void) {
    int n;
    scanf("%d", &n);

    ll sumD = 0;
    for(int i=0; i<n; ++i) {
        scanf("%d %d", &cowArr[i].t, &cowArr[i].d);
        sumD += cowArr[i].d;
    }

    std::sort(cowArr, cowArr+n);

    ll ans = 0;
    for(int i=0; i<n; ++i) {
        sumD -= cowArr[i].d;
        ans += cowArr[i].t * 2 * sumD;
    }
    printf("%lld\n", ans);

    return 0;
}
```

## XXX

**[题面]**


**[输入]**



**[输出]**


**[样例输入]**

```

```

**[样例输出]**

```

```

**[思路]**



**[参考代码]**

``` cpp

```